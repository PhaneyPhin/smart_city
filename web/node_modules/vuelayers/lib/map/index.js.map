{"version":3,"file":"index.js","sources":["src/component/map/map.vue?rollup-plugin-vue=script.js","src/component/map/map.vue","src/component/map/view.vue?rollup-plugin-vue=script.js","src/component/map/view.vue","src/component/map/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport Collection from 'ol/Collection'\nimport { defaults as createDefaultControls } from 'ol/control'\nimport { defaults as createDefaultInteractions } from 'ol/interaction'\nimport VectorLayer from 'ol/layer/Vector'\nimport Map from 'ol/Map'\nimport VectorSource from 'ol/source/Vector'\nimport View from 'ol/View'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilChanged, map as mapObs, throttleTime } from 'rxjs/operators'\nimport Vue from 'vue'\nimport {\n  featuresContainer,\n  interactionsContainer,\n  layersContainer,\n  olCmp,\n  overlaysContainer,\n  projTransforms,\n} from '../../mixin'\nimport { getMapId, initializeInteraction, setMapDataProjection, setMapId } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasMap, hasView } from '../../util/assert'\nimport { isEqual, isPlainObject } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n * rendering and low level interaction events.\n */\nexport default {\n  name: 'vl-map',\n  mixins: [\n    olCmp,\n    layersContainer,\n    interactionsContainer,\n    overlaysContainer,\n    featuresContainer,\n    projTransforms,\n  ],\n  props: {\n    /**\n     * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n     * value is used to configure controls.\n     * @type {Object|boolean|Collection}\n     * @todo remove when vl-control-* components will be ready\n     */\n    defaultControls: {\n      type: [Object, Boolean, Collection],\n      default: true,\n    },\n    /**\n     * Options for default interactions added to the map by default. Object\n     * value is used to configure default interactions.\n     * @type {Object|boolean|Collection}\n     */\n    defaultInteractions: {\n      type: [Object, Boolean, Collection],\n      default: true,\n    },\n    /**\n     * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n     * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n     * events on is the component root element.\n     * @type {string|Element|Document}\n     */\n    keyboardEventTarget: [String, Element, Document],\n    /**\n     * When set to `true`, tiles will be loaded during animations.\n     * @type {boolean}\n     */\n    loadTilesWhileAnimating: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * When set to `true`, tiles will be loaded while interacting with the map.\n     * @type {boolean}\n     */\n    loadTilesWhileInteracting: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n     * Increasing this value can make it easier to click on the map.\n     * @type {Number}\n     */\n    moveTolerance: {\n      type: Number,\n      default: 1,\n    },\n    /**\n     * The ratio between physical pixels and device-independent pixels (dips) on the device.\n     * @type {number}\n     */\n    pixelRatio: {\n      type: Number,\n      default: () => window.devicePixelRatio || 1,\n    },\n    /**\n     * Maximum number tiles to load simultaneously.\n     * @type {number}\n     */\n    maxTilesLoading: {\n      type: Number,\n      default: 16,\n    },\n    /**\n     * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n     * @type {number|string}\n     */\n    tabindex: [String, Number],\n    /**\n     * Projection for input/output coordinates in plain data.\n     * @type {string}\n     */\n    dataProjection: String,\n    /**\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  methods: {\n    /**\n     * @return {module:ol/PluggableMap~PluggableMap}\n     * @protected\n     */\n    createOlObject () {\n      const map = new Map({\n        loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n        loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n        pixelRatio: this.pixelRatio,\n        moveTolerance: this.moveTolerance,\n        keyboardEventTarget: this.keyboardEventTarget,\n        maxTilesLoading: this.maxTilesLoading,\n        controls: this._controlsCollection,\n        interactions: this.$interactionsCollection,\n        layers: this.$layersCollection,\n        overlays: this.$overlaysCollection,\n        view: this.$view,\n      })\n\n      setMapId(map, this.id)\n      setMapDataProjection(map, this.dataProjection)\n      this._featuresOverlay.setMap(map)\n\n      return map\n    },\n    /**\n     * @param {number[]} pixel\n     * @return {number[]} Coordinates in the map data projection.\n     */\n    getCoordinateFromPixel (pixel) {\n      hasMap(this)\n\n      let coordinate = this.$map.getCoordinateFromPixel(pixel)\n\n      return this.pointToDataProj(coordinate)\n    },\n    /**\n     * @param {number[]} coordinate Coordinates in map data projection\n     * @return {number[]}\n     */\n    getPixelFromCoordinate (coordinate) {\n      hasMap(this)\n\n      return this.$map.getPixelFromCoordinate(this.pointToViewProj(coordinate))\n    },\n    /**\n     * Triggers focus on map container.\n     * @return {void}\n     */\n    focus () {\n      this.$el.focus()\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function} callback\n     * @param {Object} [opts]\n     * @return {*|undefined}\n     */\n    forEachFeatureAtPixel (pixel, callback, opts = {}) {\n      hasMap(this)\n\n      return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function} callback\n     * @param {Object} [opts]\n     * @return {*|undefined}\n     */\n    forEachLayerAtPixel (pixel, callback, opts = {}) {\n      hasMap(this)\n\n      return this.$map.forEachLayerAtPixel(pixel, callback, opts)\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {Object} [opts]\n     */\n    getFeaturesAtPixel (pixel, opts = {}) {\n      hasMap(this)\n\n      return this.$map.getFeaturesAtPixel(pixel, opts)\n    },\n    /**\n     * Updates map size and re-renders map.\n     * @return {Promise}\n     */\n    refresh () {\n      this.updateSize()\n\n      return this.render().then(() => this::olCmp.methods.refresh())\n    },\n    /**\n     * @return {Promise}\n     */\n    render () {\n      return new Promise(resolve => {\n        hasMap(this)\n\n        this.$map.once('postrender', () => resolve())\n        this.$map.render()\n      })\n    },\n    /**\n     * Updates map size.\n     * @return {void}\n     */\n    updateSize () {\n      hasMap(this)\n\n      this.$map.updateSize()\n    },\n    /**\n     * @param {module:ol/View~View|Vue|undefined} view\n     * @return {void}\n     * @protected\n     */\n    setView (view) {\n      view = view instanceof Vue ? view.$view : view\n      view || (view = new View())\n\n      if (view !== this._view) {\n        this._view = view\n      }\n      if (this.$map && view !== this.$map.getView()) {\n        this.$map.setView(view)\n      }\n    },\n    /**\n     * @return {module:ol/View~View}\n     */\n    getView () {\n      return this._view\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      hasMap(this)\n\n      this.$map.setTarget(this.$el)\n      this.$nextTick(::this.updateSize)\n\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      hasMap(this)\n\n      this.clearFeatures()\n      this.clearLayers()\n      this.clearInteractions()\n      this.clearOverlays()\n\n      this.unsubscribeAll()\n      this.$map.setTarget(null)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(\n        this::olCmp.methods.getServices(),\n        this::layersContainer.methods.getServices(),\n        this::interactionsContainer.methods.getServices(),\n        this::overlaysContainer.methods.getServices(),\n        this::featuresContainer.methods.getServices(),\n        {\n          get map () { return vm.$map },\n          get view () { return vm.$view },\n          get viewContainer () { return vm },\n        },\n      )\n    },\n  },\n  watch: {\n    ...makeWatchers([\n      'keyboardEventTarget',\n      'loadTilesWhileAnimating',\n      'loadTilesWhileInteracting',\n      'moveTolerance',\n      'pixelRatio',\n      'renderer',\n      'maxTilesLoading',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n    id (value) {\n      if (!this.$map || value === getMapId(this.$map)) {\n        return\n      }\n\n      setMapId(this.$map, value)\n    },\n    controls (value) {\n      if (value === false) {\n        this._controlsCollection.clear()\n        return\n      }\n\n      value = typeof value === 'object' ? value : undefined\n      this._controlsCollection.clear()\n      this._controlsCollection.extend(createDefaultControls(value).getArray())\n    },\n    wrapX (value) {\n      if (this._featuresOverlay == null) return\n\n      this._featuresOverlay.setSource(new VectorSource({\n        features: this.$featuresCollection,\n        wrapX: value,\n      }))\n    },\n    dataProjection (value) {\n      if (!this.$map) return\n\n      setMapDataProjection(this.$map, value)\n      this.scheduleRefresh()\n    },\n  },\n  created () {\n    this._view = new View({\n      center: [0, 0],\n      zoom: 0,\n    })\n    // todo make controls handling like with interactions\n    if (this.defaultControls instanceof Collection) {\n      this._controlsCollection = this.defaultControls\n    } else if (this.defaultControls !== false) {\n      this._controlsCollection = createDefaultControls(\n        isPlainObject(this.defaultControls)\n          ? this.defaultControls\n          : undefined,\n      )\n    }\n    // todo initialize without interactions and provide vl-interaction-default component\n    if (this.defaultInteractions instanceof Collection) {\n      this._interactionsCollection = this.defaultInteractions\n    } else if (this.defaultInteractions !== false) {\n      this._interactionsCollection = createDefaultInteractions(\n        isPlainObject(this.defaultInteractions)\n          ? this.defaultInteractions\n          : undefined,\n      )\n    }\n    this._interactionsCollection.forEach(interaction => initializeInteraction(interaction))\n    // prepare default overlay\n    this._featuresOverlay = new VectorLayer({\n      source: new VectorSource({\n        features: this.$featuresCollection,\n        wrapX: this.wrapX,\n      }),\n    })\n\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    /**\n     * OpenLayers map instance.\n     * @type {module:ol/PluggableMap~PluggableMap|undefined}\n     */\n    $map: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    /**\n     * OpenLayers view instance.\n     * @type {module:ol/View~View}\n     */\n    $view: {\n      enumerable: true,\n      get: this.getView,\n    },\n  })\n}\n\n/**\n * Subscribe to OL map events.\n *\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasMap(this)\n  hasView(this)\n\n  const ft = 1000 / 60\n  // pointer\n  const pointerEvents = mergeObs(\n    observableFromOlEvent(this.$map, [\n      'click',\n      'dblclick',\n      'singleclick',\n    ]),\n    observableFromOlEvent(this.$map, [\n      'pointerdrag',\n      'pointermove',\n    ]).pipe(\n      throttleTime(ft),\n      distinctUntilChanged((a, b) => isEqual(a.coordinate, b.coordinate)),\n    ),\n  ).pipe(\n    mapObs(evt => ({\n      ...evt,\n      coordinate: this.pointToDataProj(evt.coordinate),\n    })),\n  )\n  // other\n  const otherEvents = observableFromOlEvent(this.$map, [\n    'movestart',\n    'moveend',\n    'postrender',\n    'rendercomplete',\n    'precompose',\n    'postcompose',\n    'rendercomplete',\n  ])\n\n  const events = mergeObs(pointerEvents, otherEvents)\n\n  this.subscribeTo(events, evt => {\n    this.$emit(evt.type, evt)\n  })\n}\n","<template>\n  <div :id=\"vmId\" :class=\"cmpName\" :tabindex=\"tabindex\">\n    <slot/>\n  </div>\n</template>\n\n<script>\n  import Collection from 'ol/Collection'\n  import { defaults as createDefaultControls } from 'ol/control'\n  import { defaults as createDefaultInteractions } from 'ol/interaction'\n  import VectorLayer from 'ol/layer/Vector'\n  import Map from 'ol/Map'\n  import VectorSource from 'ol/source/Vector'\n  import View from 'ol/View'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilChanged, map as mapObs, throttleTime } from 'rxjs/operators'\n  import Vue from 'vue'\n  import {\n    featuresContainer,\n    interactionsContainer,\n    layersContainer,\n    olCmp,\n    overlaysContainer,\n    projTransforms,\n  } from '../../mixin'\n  import { getMapId, initializeInteraction, setMapDataProjection, setMapId } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasMap, hasView } from '../../util/assert'\n  import { isEqual, isPlainObject } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n   * rendering and low level interaction events.\n   */\n  export default {\n    name: 'vl-map',\n    mixins: [\n      olCmp,\n      layersContainer,\n      interactionsContainer,\n      overlaysContainer,\n      featuresContainer,\n      projTransforms,\n    ],\n    props: {\n      /**\n       * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n       * value is used to configure controls.\n       * @type {Object|boolean|Collection}\n       * @todo remove when vl-control-* components will be ready\n       */\n      defaultControls: {\n        type: [Object, Boolean, Collection],\n        default: true,\n      },\n      /**\n       * Options for default interactions added to the map by default. Object\n       * value is used to configure default interactions.\n       * @type {Object|boolean|Collection}\n       */\n      defaultInteractions: {\n        type: [Object, Boolean, Collection],\n        default: true,\n      },\n      /**\n       * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n       * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n       * events on is the component root element.\n       * @type {string|Element|Document}\n       */\n      keyboardEventTarget: [String, Element, Document],\n      /**\n       * When set to `true`, tiles will be loaded during animations.\n       * @type {boolean}\n       */\n      loadTilesWhileAnimating: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * When set to `true`, tiles will be loaded while interacting with the map.\n       * @type {boolean}\n       */\n      loadTilesWhileInteracting: {\n        type: Boolean,\n        default: false,\n      },\n      /**\n       * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n       * Increasing this value can make it easier to click on the map.\n       * @type {Number}\n       */\n      moveTolerance: {\n        type: Number,\n        default: 1,\n      },\n      /**\n       * The ratio between physical pixels and device-independent pixels (dips) on the device.\n       * @type {number}\n       */\n      pixelRatio: {\n        type: Number,\n        default: () => window.devicePixelRatio || 1,\n      },\n      /**\n       * Maximum number tiles to load simultaneously.\n       * @type {number}\n       */\n      maxTilesLoading: {\n        type: Number,\n        default: 16,\n      },\n      /**\n       * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n       * @type {number|string}\n       */\n      tabindex: [String, Number],\n      /**\n       * Projection for input/output coordinates in plain data.\n       * @type {string}\n       */\n      dataProjection: String,\n      /**\n       * @type {boolean}\n       */\n      wrapX: {\n        type: Boolean,\n        default: true,\n      },\n    },\n    methods: {\n      /**\n       * @return {module:ol/PluggableMap~PluggableMap}\n       * @protected\n       */\n      createOlObject () {\n        const map = new Map({\n          loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n          loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n          pixelRatio: this.pixelRatio,\n          moveTolerance: this.moveTolerance,\n          keyboardEventTarget: this.keyboardEventTarget,\n          maxTilesLoading: this.maxTilesLoading,\n          controls: this._controlsCollection,\n          interactions: this.$interactionsCollection,\n          layers: this.$layersCollection,\n          overlays: this.$overlaysCollection,\n          view: this.$view,\n        })\n\n        setMapId(map, this.id)\n        setMapDataProjection(map, this.dataProjection)\n        this._featuresOverlay.setMap(map)\n\n        return map\n      },\n      /**\n       * @param {number[]} pixel\n       * @return {number[]} Coordinates in the map data projection.\n       */\n      getCoordinateFromPixel (pixel) {\n        hasMap(this)\n\n        let coordinate = this.$map.getCoordinateFromPixel(pixel)\n\n        return this.pointToDataProj(coordinate)\n      },\n      /**\n       * @param {number[]} coordinate Coordinates in map data projection\n       * @return {number[]}\n       */\n      getPixelFromCoordinate (coordinate) {\n        hasMap(this)\n\n        return this.$map.getPixelFromCoordinate(this.pointToViewProj(coordinate))\n      },\n      /**\n       * Triggers focus on map container.\n       * @return {void}\n       */\n      focus () {\n        this.$el.focus()\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {function} callback\n       * @param {Object} [opts]\n       * @return {*|undefined}\n       */\n      forEachFeatureAtPixel (pixel, callback, opts = {}) {\n        hasMap(this)\n\n        return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {function} callback\n       * @param {Object} [opts]\n       * @return {*|undefined}\n       */\n      forEachLayerAtPixel (pixel, callback, opts = {}) {\n        hasMap(this)\n\n        return this.$map.forEachLayerAtPixel(pixel, callback, opts)\n      },\n      /**\n       * @param {number[]} pixel\n       * @param {Object} [opts]\n       */\n      getFeaturesAtPixel (pixel, opts = {}) {\n        hasMap(this)\n\n        return this.$map.getFeaturesAtPixel(pixel, opts)\n      },\n      /**\n       * Updates map size and re-renders map.\n       * @return {Promise}\n       */\n      refresh () {\n        this.updateSize()\n\n        return this.render().then(() => this::olCmp.methods.refresh())\n      },\n      /**\n       * @return {Promise}\n       */\n      render () {\n        return new Promise(resolve => {\n          hasMap(this)\n\n          this.$map.once('postrender', () => resolve())\n          this.$map.render()\n        })\n      },\n      /**\n       * Updates map size.\n       * @return {void}\n       */\n      updateSize () {\n        hasMap(this)\n\n        this.$map.updateSize()\n      },\n      /**\n       * @param {module:ol/View~View|Vue|undefined} view\n       * @return {void}\n       * @protected\n       */\n      setView (view) {\n        view = view instanceof Vue ? view.$view : view\n        view || (view = new View())\n\n        if (view !== this._view) {\n          this._view = view\n        }\n        if (this.$map && view !== this.$map.getView()) {\n          this.$map.setView(view)\n        }\n      },\n      /**\n       * @return {module:ol/View~View}\n       */\n      getView () {\n        return this._view\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        hasMap(this)\n\n        this.$map.setTarget(this.$el)\n        this.$nextTick(::this.updateSize)\n\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        hasMap(this)\n\n        this.clearFeatures()\n        this.clearLayers()\n        this.clearInteractions()\n        this.clearOverlays()\n\n        this.unsubscribeAll()\n        this.$map.setTarget(null)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n      /**\n       * @returns {Object}\n       * @protected\n       */\n      getServices () {\n        const vm = this\n\n        return mergeDescriptors(\n          this::olCmp.methods.getServices(),\n          this::layersContainer.methods.getServices(),\n          this::interactionsContainer.methods.getServices(),\n          this::overlaysContainer.methods.getServices(),\n          this::featuresContainer.methods.getServices(),\n          {\n            get map () { return vm.$map },\n            get view () { return vm.$view },\n            get viewContainer () { return vm },\n          },\n        )\n      },\n    },\n    watch: {\n      ...makeWatchers([\n        'keyboardEventTarget',\n        'loadTilesWhileAnimating',\n        'loadTilesWhileInteracting',\n        'moveTolerance',\n        'pixelRatio',\n        'renderer',\n        'maxTilesLoading',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n      id (value) {\n        if (!this.$map || value === getMapId(this.$map)) {\n          return\n        }\n\n        setMapId(this.$map, value)\n      },\n      controls (value) {\n        if (value === false) {\n          this._controlsCollection.clear()\n          return\n        }\n\n        value = typeof value === 'object' ? value : undefined\n        this._controlsCollection.clear()\n        this._controlsCollection.extend(createDefaultControls(value).getArray())\n      },\n      wrapX (value) {\n        if (this._featuresOverlay == null) return\n\n        this._featuresOverlay.setSource(new VectorSource({\n          features: this.$featuresCollection,\n          wrapX: value,\n        }))\n      },\n      dataProjection (value) {\n        if (!this.$map) return\n\n        setMapDataProjection(this.$map, value)\n        this.scheduleRefresh()\n      },\n    },\n    created () {\n      this._view = new View({\n        center: [0, 0],\n        zoom: 0,\n      })\n      // todo make controls handling like with interactions\n      if (this.defaultControls instanceof Collection) {\n        this._controlsCollection = this.defaultControls\n      } else if (this.defaultControls !== false) {\n        this._controlsCollection = createDefaultControls(\n          isPlainObject(this.defaultControls)\n            ? this.defaultControls\n            : undefined,\n        )\n      }\n      // todo initialize without interactions and provide vl-interaction-default component\n      if (this.defaultInteractions instanceof Collection) {\n        this._interactionsCollection = this.defaultInteractions\n      } else if (this.defaultInteractions !== false) {\n        this._interactionsCollection = createDefaultInteractions(\n          isPlainObject(this.defaultInteractions)\n            ? this.defaultInteractions\n            : undefined,\n        )\n      }\n      this._interactionsCollection.forEach(interaction => initializeInteraction(interaction))\n      // prepare default overlay\n      this._featuresOverlay = new VectorLayer({\n        source: new VectorSource({\n          features: this.$featuresCollection,\n          wrapX: this.wrapX,\n        }),\n      })\n\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      /**\n       * OpenLayers map instance.\n       * @type {module:ol/PluggableMap~PluggableMap|undefined}\n       */\n      $map: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      /**\n       * OpenLayers view instance.\n       * @type {module:ol/View~View}\n       */\n      $view: {\n        enumerable: true,\n        get: this.getView,\n      },\n    })\n  }\n\n  /**\n   * Subscribe to OL map events.\n   *\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasMap(this)\n    hasView(this)\n\n    const ft = 1000 / 60\n    // pointer\n    const pointerEvents = mergeObs(\n      observableFromOlEvent(this.$map, [\n        'click',\n        'dblclick',\n        'singleclick',\n      ]),\n      observableFromOlEvent(this.$map, [\n        'pointerdrag',\n        'pointermove',\n      ]).pipe(\n        throttleTime(ft),\n        distinctUntilChanged((a, b) => isEqual(a.coordinate, b.coordinate)),\n      ),\n    ).pipe(\n      mapObs(evt => ({\n        ...evt,\n        coordinate: this.pointToDataProj(evt.coordinate),\n      })),\n    )\n    // other\n    const otherEvents = observableFromOlEvent(this.$map, [\n      'movestart',\n      'moveend',\n      'postrender',\n      'rendercomplete',\n      'precompose',\n      'postcompose',\n      'rendercomplete',\n    ])\n\n    const events = mergeObs(pointerEvents, otherEvents)\n\n    this.subscribeTo(events, evt => {\n      this.$emit(evt.type, evt)\n    })\n  }\n</script>\n","//\n//\n//\n//\n//\n//\n\nimport View from 'ol/View'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { olCmp, projTransforms } from '../../mixin'\nimport { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\nimport { observableFromOlChangeEvent } from '../../rx-ext'\nimport { hasView } from '../../util/assert'\nimport { arrayLengthValidator, coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n * **resolution**, and **rotation** of the map.\n */\nexport default {\n  name: 'vl-view',\n  mixins: [olCmp, projTransforms],\n  props: {\n    /**\n     * The center coordinate in the view projection.\n     * @type {number[]}\n     * @default [0, 0]\n     */\n    center: {\n      type: Array,\n      default: () => [0, 0],\n      validator: arrayLengthValidator(2),\n    },\n    constrainRotation: {\n      type: [Boolean, Number],\n      default: true,\n    },\n    enableRotation: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * The extent that constrains the center defined in the view projection,\n     * in other words, center cannot be set outside this extent.\n     * @default undefined\n     */\n    extent: {\n      type: Array,\n      validator: arrayLengthValidator(4),\n    },\n    maxResolution: Number,\n    minResolution: Number,\n    /**\n     * @default 28\n     */\n    maxZoom: {\n      type: Number,\n      default: MAX_ZOOM,\n    },\n    /**\n     * @default 0\n     */\n    minZoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @type {string}\n     * @default EPSG:3857\n     */\n    projection: {\n      type: String,\n      default: EPSG_3857,\n    },\n    resolution: Number,\n    resolutions: Array,\n    /**\n     * The initial rotation for the view in **radians** (positive rotation clockwise).\n     * @type {number}\n     * @vueSync\n     */\n    rotation: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n     * @type {number}\n     * @default 0\n     * @vueSync\n     */\n    zoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @default 2\n     */\n    zoomFactor: {\n      type: Number,\n      default: ZOOM_FACTOR,\n    },\n  },\n  computed: {\n    currentZoom () {\n      if (this.rev && this.$view) {\n        return this.$view.getZoom()\n      }\n\n      return this.zoom\n    },\n    currentRotation () {\n      if (this.rev && this.$view) {\n        return this.$view.getRotation()\n      }\n\n      return this.rotation\n    },\n    currentResolution () {\n      if (this.rev && this.$view) {\n        return this.$view.getResolution()\n      }\n\n      return this.resolution\n    },\n    currentCenter () {\n      if (this.rev && this.$view) {\n        return this.pointToDataProj(this.$view.getCenter())\n      }\n    },\n    currentCenterViewProj () {\n      if (this.rev && this.$view) {\n        return this.$view.getCenter()\n      }\n    },\n    /**\n     * @return {ProjectionLike}\n     */\n    resolvedDataProjection () {\n      // exclude this.projection from lookup to allow view rendering in projection\n      // that differs from data projection\n      return coalesce(\n        this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n        this.$options.dataProjection,\n        this.viewProjection,\n      )\n    },\n  },\n  methods: {\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}\n     * @param {...(AnimationOptions|function(boolean))} args\n     * @return {Promise} Resolves when animation completes\n     */\n    animate (...args) {\n      hasView(this)\n\n      let cb = noop\n      if (isFunction(args[args.length - 1])) {\n        cb = args[args.length - 1]\n        args = args.slice(0, args.length - 1)\n      }\n      args.forEach(opts => {\n        if (!Array.isArray(opts.center)) return\n        opts.center = this.pointToViewProj(opts.center)\n      })\n\n      return new Promise(\n        resolve => this.$view.animate(...args, complete => {\n          cb(complete)\n          resolve(complete)\n        }),\n      )\n    },\n    /**\n     * @return {ol/View~View}\n     * @protected\n     */\n    createOlObject () {\n      const view = new View({\n        center: this.pointToViewProj(this.center),\n        constrainRotation: this.constrainRotation,\n        enableRotation: this.enableRotation,\n        extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n        maxResolution: this.maxResolution,\n        minResolution: this.minResolution,\n        maxZoom: this.maxZoom,\n        minZoom: this.minZoom,\n        projection: this.projection,\n        resolution: this.resolution,\n        resolutions: this.resolutions,\n        rotation: this.rotation,\n        zoom: this.zoom,\n        zoomFactor: this.zoomFactor,\n      })\n\n      view.set('id', this.id)\n\n      return view\n    },\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}\n     * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent|Vue} geometryOrExtent\n     * @param {FitOptions} [options]\n     * @return {Promise} Resolves when view changes\n     */\n    fit (geometryOrExtent, options = {}) {\n      hasView(this)\n\n      // transform from GeoJSON, vl-feature to ol.Feature\n      if (isPlainObject(geometryOrExtent)) {\n        geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n      } else if (geometryOrExtent instanceof Vue) {\n        geometryOrExtent = geometryOrExtent.$geometry\n      }\n\n      let cb = options.callback || noop\n\n      return new Promise(resolve => {\n        this.$view.fit(geometryOrExtent, {\n          ...options,\n          callback: complete => {\n            cb(complete)\n            resolve(complete)\n          },\n        })\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$viewContainer && this.$viewContainer.setView(this)\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unsubscribeAll()\n      this.$viewContainer && this.$viewContainer.setView(undefined)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToEvents()\n    },\n  },\n  watch: {\n    id (value) {\n      if (!this.$view || value === this.$view.get('id')) {\n        return\n      }\n\n      this.$view.set('id', value)\n    },\n    center (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      value = this.pointToViewProj(value)\n      if (!isEqual(value, this.currentCenterViewProj)) {\n        this.$view.setCenter(value)\n      }\n    },\n    resolution (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentResolution) {\n        this.$view.setResolution(value)\n      }\n    },\n    zoom (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentZoom) {\n        this.$view.setZoom(value)\n      }\n    },\n    rotation (value) {\n      if (!this.$view || this.$view.getAnimating()) return\n\n      if (value !== this.currentRotation) {\n        this.$view.setRotation(value)\n      }\n    },\n    minZoom (value) {\n      if (!this.$view) return\n\n      if (value !== this.$view.getMinZoom()) {\n        this.$view.setMinZoom(value)\n      }\n    },\n    maxZoom (value) {\n      if (!this.$view) return\n\n      if (value !== this.$view.getMaxZoom()) {\n        this.$view.setMaxZoom(value)\n      }\n    },\n    ...makeWatchers([\n      'resolvedDataProjection',\n      'constrainRotation',\n      'enableRotation',\n      'extent',\n      'maxResolution',\n      'minResolution',\n      'projection',\n      'resolutions',\n      'zoomFactor',\n    ], () => function () {\n      this.scheduleRecreate()\n    }),\n  },\n  stubVNode: {\n    empty () {\n      return this.vmId\n    },\n  },\n  created () {\n    this::defineServices()\n  },\n}\n\nfunction defineServices () {\n  Object.defineProperties(this, {\n    /**\n     * @type {ol/View~View|undefined}\n     */\n    $view: {\n      enumerable: true,\n      get: () => this.$olObject,\n    },\n    $viewContainer: {\n      enumerable: true,\n      get: () => this.$services && this.$services.viewContainer,\n    },\n  })\n}\n\n/**\n * Subscribe to OpenLayers significant events\n * @return {void}\n * @private\n */\nfunction subscribeToEvents () {\n  hasView(this)\n\n  const ft = 1000 / 60\n  const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n  const zoom = resolution.pipe(\n    mapObs(() => ({\n      prop: 'zoom',\n      value: this.$view.getZoom(),\n    })),\n    distinctUntilKeyChanged('value'),\n  )\n\n  const changes = mergeObs(\n    observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n    observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n    resolution,\n    zoom,\n  )\n\n  this.subscribeTo(changes, ({ prop, value }) => {\n    ++this.rev\n\n    this.$nextTick(() => {\n      this.$emit(`update:${prop}`, value)\n    })\n  })\n}\n","<template>\n  <i :id=\"vmId\" :class=\"cmpName\" style=\"display: none !important;\">\n    <slot :center=\"currentCenter\" :zoom=\"currentZoom\" :resolution=\"currentResolution\" :rotation=\"currentRotation\"/>\n  </i>\n</template>\n\n<script>\n  import View from 'ol/View'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { olCmp, projTransforms } from '../../mixin'\n  import { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\n  import { observableFromOlChangeEvent } from '../../rx-ext'\n  import { hasView } from '../../util/assert'\n  import { arrayLengthValidator, coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n   * **resolution**, and **rotation** of the map.\n   */\n  export default {\n    name: 'vl-view',\n    mixins: [olCmp, projTransforms],\n    props: {\n      /**\n       * The center coordinate in the view projection.\n       * @type {number[]}\n       * @default [0, 0]\n       */\n      center: {\n        type: Array,\n        default: () => [0, 0],\n        validator: arrayLengthValidator(2),\n      },\n      constrainRotation: {\n        type: [Boolean, Number],\n        default: true,\n      },\n      enableRotation: {\n        type: Boolean,\n        default: true,\n      },\n      /**\n       * The extent that constrains the center defined in the view projection,\n       * in other words, center cannot be set outside this extent.\n       * @default undefined\n       */\n      extent: {\n        type: Array,\n        validator: arrayLengthValidator(4),\n      },\n      maxResolution: Number,\n      minResolution: Number,\n      /**\n       * @default 28\n       */\n      maxZoom: {\n        type: Number,\n        default: MAX_ZOOM,\n      },\n      /**\n       * @default 0\n       */\n      minZoom: {\n        type: Number,\n        default: MIN_ZOOM,\n      },\n      /**\n       * @type {string}\n       * @default EPSG:3857\n       */\n      projection: {\n        type: String,\n        default: EPSG_3857,\n      },\n      resolution: Number,\n      resolutions: Array,\n      /**\n       * The initial rotation for the view in **radians** (positive rotation clockwise).\n       * @type {number}\n       * @vueSync\n       */\n      rotation: {\n        type: Number,\n        default: 0,\n      },\n      /**\n       * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n       * @type {number}\n       * @default 0\n       * @vueSync\n       */\n      zoom: {\n        type: Number,\n        default: MIN_ZOOM,\n      },\n      /**\n       * @default 2\n       */\n      zoomFactor: {\n        type: Number,\n        default: ZOOM_FACTOR,\n      },\n    },\n    computed: {\n      currentZoom () {\n        if (this.rev && this.$view) {\n          return this.$view.getZoom()\n        }\n\n        return this.zoom\n      },\n      currentRotation () {\n        if (this.rev && this.$view) {\n          return this.$view.getRotation()\n        }\n\n        return this.rotation\n      },\n      currentResolution () {\n        if (this.rev && this.$view) {\n          return this.$view.getResolution()\n        }\n\n        return this.resolution\n      },\n      currentCenter () {\n        if (this.rev && this.$view) {\n          return this.pointToDataProj(this.$view.getCenter())\n        }\n      },\n      currentCenterViewProj () {\n        if (this.rev && this.$view) {\n          return this.$view.getCenter()\n        }\n      },\n      /**\n       * @return {ProjectionLike}\n       */\n      resolvedDataProjection () {\n        // exclude this.projection from lookup to allow view rendering in projection\n        // that differs from data projection\n        return coalesce(\n          this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n          this.$options.dataProjection,\n          this.viewProjection,\n        )\n      },\n    },\n    methods: {\n      /**\n       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}\n       * @param {...(AnimationOptions|function(boolean))} args\n       * @return {Promise} Resolves when animation completes\n       */\n      animate (...args) {\n        hasView(this)\n\n        let cb = noop\n        if (isFunction(args[args.length - 1])) {\n          cb = args[args.length - 1]\n          args = args.slice(0, args.length - 1)\n        }\n        args.forEach(opts => {\n          if (!Array.isArray(opts.center)) return\n          opts.center = this.pointToViewProj(opts.center)\n        })\n\n        return new Promise(\n          resolve => this.$view.animate(...args, complete => {\n            cb(complete)\n            resolve(complete)\n          }),\n        )\n      },\n      /**\n       * @return {ol/View~View}\n       * @protected\n       */\n      createOlObject () {\n        const view = new View({\n          center: this.pointToViewProj(this.center),\n          constrainRotation: this.constrainRotation,\n          enableRotation: this.enableRotation,\n          extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n          maxResolution: this.maxResolution,\n          minResolution: this.minResolution,\n          maxZoom: this.maxZoom,\n          minZoom: this.minZoom,\n          projection: this.projection,\n          resolution: this.resolution,\n          resolutions: this.resolutions,\n          rotation: this.rotation,\n          zoom: this.zoom,\n          zoomFactor: this.zoomFactor,\n        })\n\n        view.set('id', this.id)\n\n        return view\n      },\n      /**\n       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}\n       * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent|Vue} geometryOrExtent\n       * @param {FitOptions} [options]\n       * @return {Promise} Resolves when view changes\n       */\n      fit (geometryOrExtent, options = {}) {\n        hasView(this)\n\n        // transform from GeoJSON, vl-feature to ol.Feature\n        if (isPlainObject(geometryOrExtent)) {\n          geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n        } else if (geometryOrExtent instanceof Vue) {\n          geometryOrExtent = geometryOrExtent.$geometry\n        }\n\n        let cb = options.callback || noop\n\n        return new Promise(resolve => {\n          this.$view.fit(geometryOrExtent, {\n            ...options,\n            callback: complete => {\n              cb(complete)\n              resolve(complete)\n            },\n          })\n        })\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      mount () {\n        this.$viewContainer && this.$viewContainer.setView(this)\n        this.subscribeAll()\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      unmount () {\n        this.unsubscribeAll()\n        this.$viewContainer && this.$viewContainer.setView(undefined)\n      },\n      /**\n       * @return {void}\n       * @protected\n       */\n      subscribeAll () {\n        this::subscribeToEvents()\n      },\n    },\n    watch: {\n      id (value) {\n        if (!this.$view || value === this.$view.get('id')) {\n          return\n        }\n\n        this.$view.set('id', value)\n      },\n      center (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        value = this.pointToViewProj(value)\n        if (!isEqual(value, this.currentCenterViewProj)) {\n          this.$view.setCenter(value)\n        }\n      },\n      resolution (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentResolution) {\n          this.$view.setResolution(value)\n        }\n      },\n      zoom (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentZoom) {\n          this.$view.setZoom(value)\n        }\n      },\n      rotation (value) {\n        if (!this.$view || this.$view.getAnimating()) return\n\n        if (value !== this.currentRotation) {\n          this.$view.setRotation(value)\n        }\n      },\n      minZoom (value) {\n        if (!this.$view) return\n\n        if (value !== this.$view.getMinZoom()) {\n          this.$view.setMinZoom(value)\n        }\n      },\n      maxZoom (value) {\n        if (!this.$view) return\n\n        if (value !== this.$view.getMaxZoom()) {\n          this.$view.setMaxZoom(value)\n        }\n      },\n      ...makeWatchers([\n        'resolvedDataProjection',\n        'constrainRotation',\n        'enableRotation',\n        'extent',\n        'maxResolution',\n        'minResolution',\n        'projection',\n        'resolutions',\n        'zoomFactor',\n      ], () => function () {\n        this.scheduleRecreate()\n      }),\n    },\n    stubVNode: {\n      empty () {\n        return this.vmId\n      },\n    },\n    created () {\n      this::defineServices()\n    },\n  }\n\n  function defineServices () {\n    Object.defineProperties(this, {\n      /**\n       * @type {ol/View~View|undefined}\n       */\n      $view: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      $viewContainer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.viewContainer,\n      },\n    })\n  }\n\n  /**\n   * Subscribe to OpenLayers significant events\n   * @return {void}\n   * @private\n   */\n  function subscribeToEvents () {\n    hasView(this)\n\n    const ft = 1000 / 60\n    const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n    const zoom = resolution.pipe(\n      mapObs(() => ({\n        prop: 'zoom',\n        value: this.$view.getZoom(),\n      })),\n      distinctUntilKeyChanged('value'),\n    )\n\n    const changes = mergeObs(\n      observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n      observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n      resolution,\n      zoom,\n    )\n\n    this.subscribeTo(changes, ({ prop, value }) => {\n      ++this.rev\n\n      this.$nextTick(() => {\n        this.$emit(`update:${prop}`, value)\n      })\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Map from './map.vue'\nimport View from './view.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Map, options)\n  Object.assign(View, options)\n\n  Vue.component(Map.name, Map)\n  Vue.component(View.name, View)\n}\n\nexport default plugin\n\nexport {\n  Map,\n  View,\n  plugin as install,\n}\n"],"names":["name","mixins","olCmp","layersContainer","interactionsContainer","overlaysContainer","featuresContainer","projTransforms","props","defaultControls","type","Object","Boolean","Collection","default","defaultInteractions","keyboardEventTarget","String","Element","Document","loadTilesWhileAnimating","loadTilesWhileInteracting","moveTolerance","Number","pixelRatio","window","devicePixelRatio","maxTilesLoading","tabindex","dataProjection","wrapX","methods","createOlObject","map","Map","controls","_controlsCollection","interactions","$interactionsCollection","layers","$layersCollection","overlays","$overlaysCollection","view","$view","setMapId","id","setMapDataProjection","_featuresOverlay","setMap","getCoordinateFromPixel","pixel","hasMap","coordinate","$map","pointToDataProj","getPixelFromCoordinate","pointToViewProj","focus","$el","forEachFeatureAtPixel","callback","opts","forEachLayerAtPixel","getFeaturesAtPixel","refresh","updateSize","render","then","resolve","once","setView","Vue","View","_view","getView","mount","setTarget","$nextTick","subscribeAll","unmount","clearFeatures","clearLayers","clearInteractions","clearOverlays","unsubscribeAll","subscribeToEvents","getServices","vm","mergeDescriptors","viewContainer","watch","makeWatchers","scheduleRecreate","value","getMapId","clear","undefined","extend","createDefaultControls","getArray","setSource","VectorSource","features","$featuresCollection","scheduleRefresh","created","center","zoom","isPlainObject","_interactionsCollection","createDefaultInteractions","interaction","initializeInteraction","VectorLayer","source","defineServices","enumerable","get","$olObject","hasView","ft","pointerEvents","mergeObs","observableFromOlEvent","pipe","throttleTime","distinctUntilChanged","a","b","isEqual","mapObs","evt","otherEvents","events","subscribeTo","$emit","Array","validator","arrayLengthValidator","constrainRotation","enableRotation","extent","maxResolution","minResolution","maxZoom","MAX_ZOOM","minZoom","MIN_ZOOM","projection","EPSG_3857","resolution","resolutions","rotation","zoomFactor","ZOOM_FACTOR","computed","currentZoom","rev","getZoom","currentRotation","getRotation","currentResolution","getResolution","currentCenter","getCenter","currentCenterViewProj","resolvedDataProjection","coalesce","$viewContainer","$options","viewProjection","animate","args","cb","noop","isFunction","length","complete","extentToViewProj","set","fit","geometryOrExtent","options","readGeometryInDataProj","$geometry","getAnimating","setCenter","setResolution","setZoom","setRotation","getMinZoom","setMinZoom","getMaxZoom","setMaxZoom","stubVNode","empty","vmId","$services","observableFromOlChangeEvent","prop","distinctUntilKeyChanged","changes","plugin","installed","pick","component"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;AAIA,aAAe;EACbA,IAAI,EAAE,QADO;EAEbC,MAAM,EAAE,CACNC,KADM,EAENC,eAFM,EAGNC,qBAHM,EAINC,iBAJM,EAKNC,iBALM,EAMNC,cANM,CAFK;EAUbC,KAAK,EAAE;;;;;;;IAOLC,eAAe,EAAE;MACfC,IAAI,EAAE,CAACC,MAAD,EAASC,OAAT,EAAkBC,UAAlB,CADS;MAEfC,OAAO,EAAE;KATN;;;;;;;IAgBLC,mBAAmB,EAAE;MACnBL,IAAI,EAAE,CAACC,MAAD,EAASC,OAAT,EAAkBC,UAAlB,CADa;MAEnBC,OAAO,EAAE;KAlBN;;;;;;;;IA0BLE,mBAAmB,EAAE,CAACC,MAAD,EAASC,OAAT,EAAkBC,QAAlB,CA1BhB;;;;;;IA+BLC,uBAAuB,EAAE;MACvBV,IAAI,EAAEE,OADiB;MAEvBE,OAAO,EAAE;KAjCN;;;;;;IAuCLO,yBAAyB,EAAE;MACzBX,IAAI,EAAEE,OADmB;MAEzBE,OAAO,EAAE;KAzCN;;;;;;;IAgDLQ,aAAa,EAAE;MACbZ,IAAI,EAAEa,MADO;MAEbT,OAAO,EAAE;KAlDN;;;;;;IAwDLU,UAAU,EAAE;MACVd,IAAI,EAAEa,MADI;MAEVT,OAAO,EAAE;eAAMW,MAAM,CAACC,gBAAP,IAA2B,CAAjC;;KA1DN;;;;;;IAgELC,eAAe,EAAE;MACfjB,IAAI,EAAEa,MADS;MAEfT,OAAO,EAAE;KAlEN;;;;;;IAwELc,QAAQ,EAAE,CAACX,MAAD,EAASM,MAAT,CAxEL;;;;;;IA6ELM,cAAc,EAAEZ,MA7EX;;;;;IAiFLa,KAAK,EAAE;MACLpB,IAAI,EAAEE,OADD;MAELE,OAAO,EAAE;;GA7FA;EAgGbiB,OAAO,EAAE;;;;;IAKPC,cALO,4BAKW;UACVC,MAAG,GAAG,IAAIC,GAAJ,CAAQ;QAClBd,uBAAuB,EAAE,KAAKA,uBADZ;QAElBC,yBAAyB,EAAE,KAAKA,yBAFd;QAGlBG,UAAU,EAAE,KAAKA,UAHC;QAIlBF,aAAa,EAAE,KAAKA,aAJF;QAKlBN,mBAAmB,EAAE,KAAKA,mBALR;QAMlBW,eAAe,EAAE,KAAKA,eANJ;QAOlBQ,QAAQ,EAAE,KAAKC,mBAPG;QAQlBC,YAAY,EAAE,KAAKC,uBARD;QASlBC,MAAM,EAAE,KAAKC,iBATK;QAUlBC,QAAQ,EAAE,KAAKC,mBAVG;QAWlBC,IAAI,EAAE,KAAKC;OAXD,CAAZ;MAcAC,QAAQ,CAACZ,MAAD,EAAM,KAAKa,EAAX,CAAR;MACAC,oBAAoB,CAACd,MAAD,EAAM,KAAKJ,cAAX,CAApB;;WACKmB,gBAAL,CAAsBC,MAAtB,CAA6BhB,MAA7B;;aAEOA,MAAP;KAxBK;;;;;;IA8BPiB,sBA9BO,kCA8BiBC,KA9BjB,EA8BwB;MAC7BC,MAAM,CAAC,IAAD,CAAN;UAEIC,UAAU,GAAG,KAAKC,IAAL,CAAUJ,sBAAV,CAAiCC,KAAjC,CAAjB;aAEO,KAAKI,eAAL,CAAqBF,UAArB,CAAP;KAnCK;;;;;;IAyCPG,sBAzCO,kCAyCiBH,UAzCjB,EAyC6B;MAClCD,MAAM,CAAC,IAAD,CAAN;aAEO,KAAKE,IAAL,CAAUE,sBAAV,CAAiC,KAAKC,eAAL,CAAqBJ,UAArB,CAAjC,CAAP;KA5CK;;;;;;IAkDPK,KAlDO,mBAkDE;WACFC,GAAL,CAASD,KAAT;KAnDK;;;;;;;;IA2DPE,qBA3DO,iCA2DgBT,KA3DhB,EA2DuBU,QA3DvB,EA2D4C;UAAXC,IAAW,uEAAJ,EAAI;MACjDV,MAAM,CAAC,IAAD,CAAN;aAEO,KAAKE,IAAL,CAAUM,qBAAV,CAAgCT,KAAhC,EAAuCU,QAAvC,EAAiDC,IAAjD,CAAP;KA9DK;;;;;;;;IAsEPC,mBAtEO,+BAsEcZ,KAtEd,EAsEqBU,QAtErB,EAsE0C;UAAXC,IAAW,uEAAJ,EAAI;MAC/CV,MAAM,CAAC,IAAD,CAAN;aAEO,KAAKE,IAAL,CAAUS,mBAAV,CAA8BZ,KAA9B,EAAqCU,QAArC,EAA+CC,IAA/C,CAAP;KAzEK;;;;;;IA+EPE,kBA/EO,8BA+Eab,KA/Eb,EA+E+B;UAAXW,IAAW,uEAAJ,EAAI;MACpCV,MAAM,CAAC,IAAD,CAAN;aAEO,KAAKE,IAAL,CAAUU,kBAAV,CAA6Bb,KAA7B,EAAoCW,IAApC,CAAP;KAlFK;;;;;;IAwFPG,OAxFO,qBAwFI;;;WACJC,UAAL;aAEO,KAAKC,MAAL,GAAcC,IAAd,CAAmB;eAAYlE,KAAK,CAAC6B,OAAN,CAAckC,OAApB,MAAA,KAAI,CAAV;OAAnB,CAAP;KA3FK;;;;;IAgGPE,MAhGO,oBAgGG;;;aACD,aAAY,UAAAE,OAAO,EAAI;QAC5BjB,MAAM,CAAC,MAAD,CAAN;;QAEA,MAAI,CAACE,IAAL,CAAUgB,IAAV,CAAe,YAAf,EAA6B;iBAAMD,OAAO,EAAb;SAA7B;;QACA,MAAI,CAACf,IAAL,CAAUa,MAAV;OAJK,CAAP;KAjGK;;;;;;IA4GPD,UA5GO,wBA4GO;MACZd,MAAM,CAAC,IAAD,CAAN;WAEKE,IAAL,CAAUY,UAAV;KA/GK;;;;;;;IAsHPK,OAtHO,mBAsHE5B,IAtHF,EAsHQ;MACbA,IAAI,GAAGA,IAAI,YAAY6B,GAAhB,GAAsB7B,IAAI,CAACC,KAA3B,GAAmCD,IAA1C;MACAA,IAAI,KAAKA,IAAI,GAAG,IAAI8B,IAAJ,EAAZ,CAAJ;;UAEI9B,IAAI,KAAK,KAAK+B,KAAlB,EAAyB;aAClBA,KAAL,GAAa/B,IAAb;;;UAEE,KAAKW,IAAL,IAAaX,IAAI,KAAK,KAAKW,IAAL,CAAUqB,OAAV,EAA1B,EAA+C;aACxCrB,IAAL,CAAUiB,OAAV,CAAkB5B,IAAlB;;KA9HG;;;;;IAoIPgC,OApIO,qBAoII;aACF,KAAKD,KAAZ;KArIK;;;;;;IA2IPE,KA3IO,mBA2IE;;;MACPxB,MAAM,CAAC,IAAD,CAAN;WAEKE,IAAL,CAAUuB,SAAV,CAAoB,KAAKlB,GAAzB;WACKmB,SAAL,kCAAiB,KAAKZ,UAAtB,iBAAiB,IAAjB;WAEKa,YAAL;KAjJK;;;;;;IAuJPC,OAvJO,qBAuJI;MACT5B,MAAM,CAAC,IAAD,CAAN;WAEK6B,aAAL;WACKC,WAAL;WACKC,iBAAL;WACKC,aAAL;WAEKC,cAAL;WACK/B,IAAL,CAAUuB,SAAV,CAAoB,IAApB;KAhKK;;;;;;IAsKPE,YAtKO,0BAsKS;MACRO,iBAAN;KAvKK;;;;;;IA6KPC,WA7KO,yBA6KQ;UACPC,EAAE,GAAG,IAAX;aAEOC,gBAAgB,CACfvF,KAAK,CAAC6B,OAAN,CAAcwD,WAApB,WADqB,EAEfpF,eAAe,CAAC4B,OAAhB,CAAwBwD,WAA9B,WAFqB,EAGfnF,qBAAqB,CAAC2B,OAAtB,CAA8BwD,WAApC,WAHqB,EAIflF,iBAAiB,CAAC0B,OAAlB,CAA0BwD,WAAhC,WAJqB,EAKfjF,iBAAiB,CAACyB,OAAlB,CAA0BwD,WAAhC,WALqB,EAMrB;YACMtD,GAAJ,GAAW;iBAASuD,EAAE,CAAClC,IAAV;SADf;;YAEMX,IAAJ,GAAY;iBAAS6C,EAAE,CAAC5C,KAAV;SAFhB;;YAGM8C,aAAJ,GAAqB;iBAASF,EAAP;;;OATJ,CAAvB;;GAhRS;EA8RbG,KAAK,oBACAC,YAAY,CAAC,CACd,qBADc,EAEd,yBAFc,EAGd,2BAHc,EAId,eAJc,EAKd,YALc,EAMd,UANc,EAOd,iBAPc,CAAD,EAQZ;WAAM,YAAY;WACdC,gBAAL;KADC;GARY,CADZ;IAYH/C,EAZG,cAYCgD,KAZD,EAYQ;UACL,CAAC,KAAKxC,IAAN,IAAcwC,KAAK,KAAKC,QAAQ,CAAC,KAAKzC,IAAN,CAApC,EAAiD;;;;MAIjDT,QAAQ,CAAC,KAAKS,IAAN,EAAYwC,KAAZ,CAAR;KAjBC;IAmBH3D,QAnBG,oBAmBO2D,KAnBP,EAmBc;UACXA,KAAK,KAAK,KAAd,EAAqB;aACd1D,mBAAL,CAAyB4D,KAAzB;;;;;MAIFF,KAAK,GAAG,QAAOA,KAAP,MAAiB,QAAjB,GAA4BA,KAA5B,GAAoCG,SAA5C;;WACK7D,mBAAL,CAAyB4D,KAAzB;;WACK5D,mBAAL,CAAyB8D,MAAzB,CAAgCC,QAAqB,CAACL,KAAD,CAArB,CAA6BM,QAA7B,EAAhC;KA3BC;IA6BHtE,KA7BG,iBA6BIgE,KA7BJ,EA6BW;UACR,KAAK9C,gBAAL,IAAyB,IAA7B,EAAmC;;WAE9BA,gBAAL,CAAsBqD,SAAtB,CAAgC,IAAIC,YAAJ,CAAiB;QAC/CC,QAAQ,EAAE,KAAKC,mBADgC;QAE/C1E,KAAK,EAAEgE;OAFuB,CAAhC;KAhCC;IAqCHjE,cArCG,0BAqCaiE,KArCb,EAqCoB;UACjB,CAAC,KAAKxC,IAAV,EAAgB;MAEhBP,oBAAoB,CAAC,KAAKO,IAAN,EAAYwC,KAAZ,CAApB;WACKW,eAAL;;IAvUS;EA0UbC,OA1Ua,qBA0UF;;;SACJhC,KAAL,GAAa,IAAID,IAAJ,CAAS;MACpBkC,MAAM,EAAE,CAAC,CAAD,EAAI,CAAJ,CADY;MAEpBC,IAAI,EAAE;KAFK,CAAb,CADS;;QAML,KAAKnG,eAAL,YAAgCI,UAApC,EAAgD;WACzCuB,mBAAL,GAA2B,KAAK3B,eAAhC;KADF,MAEO,IAAI,KAAKA,eAAL,KAAyB,KAA7B,EAAoC;WACpC2B,mBAAL,GAA2B+D,QAAqB,CAC9CU,aAAa,CAAC,KAAKpG,eAAN,CAAb,GACI,KAAKA,eADT,GAEIwF,SAH0C,CAAhD;KATO;;;QAgBL,KAAKlF,mBAAL,YAAoCF,UAAxC,EAAoD;WAC7CiG,uBAAL,GAA+B,KAAK/F,mBAApC;KADF,MAEO,IAAI,KAAKA,mBAAL,KAA6B,KAAjC,EAAwC;WACxC+F,uBAAL,GAA+BC,UAAyB,CACtDF,aAAa,CAAC,KAAK9F,mBAAN,CAAb,GACI,KAAKA,mBADT,GAEIkF,SAHkD,CAAxD;;;8CAMGa,uBAAL,kBAAqC,UAAAE,WAAW;aAAIC,qBAAqB,CAACD,WAAD,CAAzB;KAAhD,EAzBS;;;SA2BJhE,gBAAL,GAAwB,IAAIkE,WAAJ,CAAgB;MACtCC,MAAM,EAAE,IAAIb,YAAJ,CAAiB;QACvBC,QAAQ,EAAE,KAAKC,mBADQ;QAEvB1E,KAAK,EAAE,KAAKA;OAFN;KADc,CAAxB;IAOMsF,cAAN;;CA5WJ;;AAgXA,SAASA,cAAT,GAA2B;;;2BACD,IAAxB,EAA8B;;;;;IAK5B9D,IAAI,EAAE;MACJ+D,UAAU,EAAE,IADR;MAEJC,GAAG,EAAE;eAAM,MAAI,CAACC,SAAX;;KAPqB;;;;;;IAa5B3E,KAAK,EAAE;MACLyE,UAAU,EAAE,IADP;MAELC,GAAG,EAAE,KAAK3C;;GAfd;;;;;;;;;;AA0BF,SAASW,iBAAT,GAA8B;;;EAC5BlC,MAAM,CAAC,IAAD,CAAN;EACAoE,OAAO,CAAC,IAAD,CAAP;MAEMC,EAAE,GAAG,OAAO,EAAlB,CAJ4B;;MAMtBC,aAAa,GAAGC,KAAQ,CAC5BC,qBAAqB,CAAC,KAAKtE,IAAN,EAAY,CAC/B,OAD+B,EAE/B,UAF+B,EAG/B,aAH+B,CAAZ,CADO,EAM5BsE,qBAAqB,CAAC,KAAKtE,IAAN,EAAY,CAC/B,aAD+B,EAE/B,aAF+B,CAAZ,CAArB,CAGGuE,IAHH,CAIEC,YAAY,CAACL,EAAD,CAJd,EAKEM,oBAAoB,CAAC,UAACC,CAAD,EAAIC,CAAJ;WAAUC,OAAO,CAACF,CAAC,CAAC3E,UAAH,EAAe4E,CAAC,CAAC5E,UAAjB,CAAjB;GAAD,CALtB,CAN4B,CAAR,CAapBwE,IAboB,CAcpBM,GAAM,CAAC,UAAAC,GAAG;6BACLA,GADK;MAER/E,UAAU,EAAE,MAAI,CAACE,eAAL,CAAqB6E,GAAG,CAAC/E,UAAzB;;GAFR,CAdc,CAAtB,CAN4B;;MA0BtBgF,WAAW,GAAGT,qBAAqB,CAAC,KAAKtE,IAAN,EAAY,CACnD,WADmD,EAEnD,SAFmD,EAGnD,YAHmD,EAInD,gBAJmD,EAKnD,YALmD,EAMnD,aANmD,EAOnD,gBAPmD,CAAZ,CAAzC;MAUMgF,MAAM,GAAGX,KAAQ,CAACD,aAAD,EAAgBW,WAAhB,CAAvB;OAEKE,WAAL,CAAiBD,MAAjB,EAAyB,UAAAF,GAAG,EAAI;IAC9B,MAAI,CAACI,KAAL,CAAWJ,GAAG,CAAC1H,IAAf,EAAqB0H,GAArB;GADF;;;ACldU,2BAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACeZ;;;;;AAIA,eAAe;EACbpI,IAAI,EAAE,SADO;EAEbC,MAAM,EAAE,CAACC,KAAD,EAAQK,cAAR,CAFK;EAGbC,KAAK,EAAE;;;;;;IAMLmG,MAAM,EAAE;MACNjG,IAAI,EAAE+H,KADA;MAEN3H,OAAO,EAAE;eAAM,CAAC,CAAD,EAAI,CAAJ,CAAN;OAFH;MAGN4H,SAAS,EAAEC,oBAAoB,CAAC,CAAD;KAT5B;IAWLC,iBAAiB,EAAE;MACjBlI,IAAI,EAAE,CAACE,OAAD,EAAUW,MAAV,CADW;MAEjBT,OAAO,EAAE;KAbN;IAeL+H,cAAc,EAAE;MACdnI,IAAI,EAAEE,OADQ;MAEdE,OAAO,EAAE;KAjBN;;;;;;;IAwBLgI,MAAM,EAAE;MACNpI,IAAI,EAAE+H,KADA;MAENC,SAAS,EAAEC,oBAAoB,CAAC,CAAD;KA1B5B;IA4BLI,aAAa,EAAExH,MA5BV;IA6BLyH,aAAa,EAAEzH,MA7BV;;;;;IAiCL0H,OAAO,EAAE;MACPvI,IAAI,EAAEa,MADC;MAEPT,OAAO,EAAEoI;KAnCN;;;;;IAwCLC,OAAO,EAAE;MACPzI,IAAI,EAAEa,MADC;MAEPT,OAAO,EAAEsI;KA1CN;;;;;;IAgDLC,UAAU,EAAE;MACV3I,IAAI,EAAEO,MADI;MAEVH,OAAO,EAAEwI;KAlDN;IAoDLC,UAAU,EAAEhI,MApDP;IAqDLiI,WAAW,EAAEf,KArDR;;;;;;;IA2DLgB,QAAQ,EAAE;MACR/I,IAAI,EAAEa,MADE;MAERT,OAAO,EAAE;KA7DN;;;;;;;;IAqEL8F,IAAI,EAAE;MACJlG,IAAI,EAAEa,MADF;MAEJT,OAAO,EAAEsI;KAvEN;;;;;IA4ELM,UAAU,EAAE;MACVhJ,IAAI,EAAEa,MADI;MAEVT,OAAO,EAAE6I;;GAjFA;EAoFbC,QAAQ,EAAE;IACRC,WADQ,yBACO;UACT,KAAKC,GAAL,IAAY,KAAKlH,KAArB,EAA4B;eACnB,KAAKA,KAAL,CAAWmH,OAAX,EAAP;;;aAGK,KAAKnD,IAAZ;KANM;IAQRoD,eARQ,6BAQW;UACb,KAAKF,GAAL,IAAY,KAAKlH,KAArB,EAA4B;eACnB,KAAKA,KAAL,CAAWqH,WAAX,EAAP;;;aAGK,KAAKR,QAAZ;KAbM;IAeRS,iBAfQ,+BAea;UACf,KAAKJ,GAAL,IAAY,KAAKlH,KAArB,EAA4B;eACnB,KAAKA,KAAL,CAAWuH,aAAX,EAAP;;;aAGK,KAAKZ,UAAZ;KApBM;IAsBRa,aAtBQ,2BAsBS;UACX,KAAKN,GAAL,IAAY,KAAKlH,KAArB,EAA4B;eACnB,KAAKW,eAAL,CAAqB,KAAKX,KAAL,CAAWyH,SAAX,EAArB,CAAP;;KAxBI;IA2BRC,qBA3BQ,mCA2BiB;UACnB,KAAKR,GAAL,IAAY,KAAKlH,KAArB,EAA4B;eACnB,KAAKA,KAAL,CAAWyH,SAAX,EAAP;;KA7BI;;;;;IAmCRE,sBAnCQ,oCAmCkB;;;aAGjBC,QAAQ,CACb,KAAKC,cAAL,IAAuB,KAAKA,cAAL,CAAoBF,sBAD9B,EAEb,KAAKG,QAAL,CAAc7I,cAFD,EAGb,KAAK8I,cAHQ,CAAf;;GA1HS;EAiIb5I,OAAO,EAAE;;;;;;IAMP6I,OANO,qBAMW;;;wCAANC,IAAM;QAANA,IAAM;;;MAChBrD,OAAO,CAAC,IAAD,CAAP;UAEIsD,EAAE,GAAGC,IAAT;;UACIC,UAAU,CAACH,IAAI,CAACA,IAAI,CAACI,MAAL,GAAc,CAAf,CAAL,CAAd,EAAuC;QACrCH,EAAE,GAAGD,IAAI,CAACA,IAAI,CAACI,MAAL,GAAc,CAAf,CAAT;QACAJ,IAAI,GAAG,uBAAAA,IAAI,MAAJ,CAAAA,IAAI,EAAO,CAAP,EAAUA,IAAI,CAACI,MAAL,GAAc,CAAxB,CAAX;;;+BAEFJ,IAAI,MAAJ,CAAAA,IAAI,EAAS,UAAA/G,IAAI,EAAI;YACf,CAAC,eAAcA,IAAI,CAAC6C,MAAnB,CAAL,EAAiC;QACjC7C,IAAI,CAAC6C,MAAL,GAAc,KAAI,CAAClD,eAAL,CAAqBK,IAAI,CAAC6C,MAA1B,CAAd;OAFE,CAAJ;;aAKO,aACL,UAAAtC,OAAO;;;eAAI,eAAA,KAAI,CAACzB,KAAL,EAAWgI,OAAX,0EAAsBC,IAAtB,mBAA4B,UAAAK,QAAQ,EAAI;UACjDJ,EAAE,CAACI,QAAD,CAAF;UACA7G,OAAO,CAAC6G,QAAD,CAAP;SAFS,GAAJ;OADF,CAAP;KAnBK;;;;;;IA8BPlJ,cA9BO,4BA8BW;UACVW,IAAI,GAAG,IAAI8B,IAAJ,CAAS;QACpBkC,MAAM,EAAE,KAAKlD,eAAL,CAAqB,KAAKkD,MAA1B,CADY;QAEpBiC,iBAAiB,EAAE,KAAKA,iBAFJ;QAGpBC,cAAc,EAAE,KAAKA,cAHD;QAIpBC,MAAM,EAAE,KAAKA,MAAL,GAAc,KAAKqC,gBAAL,CAAsB,KAAKrC,MAA3B,CAAd,GAAmD7C,SAJvC;QAKpB8C,aAAa,EAAE,KAAKA,aALA;QAMpBC,aAAa,EAAE,KAAKA,aANA;QAOpBC,OAAO,EAAE,KAAKA,OAPM;QAQpBE,OAAO,EAAE,KAAKA,OARM;QASpBE,UAAU,EAAE,KAAKA,UATG;QAUpBE,UAAU,EAAE,KAAKA,UAVG;QAWpBC,WAAW,EAAE,KAAKA,WAXE;QAYpBC,QAAQ,EAAE,KAAKA,QAZK;QAapB7C,IAAI,EAAE,KAAKA,IAbS;QAcpB8C,UAAU,EAAE,KAAKA;OAdN,CAAb;MAiBA/G,IAAI,CAACyI,GAAL,CAAS,IAAT,EAAe,KAAKtI,EAApB;aAEOH,IAAP;KAlDK;;;;;;;;IA0DP0I,GA1DO,eA0DFC,gBA1DE,EA0D8B;;;UAAdC,OAAc,uEAAJ,EAAI;MACnC/D,OAAO,CAAC,IAAD,CAAP,CADmC;;UAI/BX,aAAa,CAACyE,gBAAD,CAAjB,EAAqC;QACnCA,gBAAgB,GAAG,KAAKE,sBAAL,CAA4BF,gBAA5B,CAAnB;OADF,MAEO,IAAIA,gBAAgB,YAAY9G,GAAhC,EAAqC;QAC1C8G,gBAAgB,GAAGA,gBAAgB,CAACG,SAApC;;;UAGEX,EAAE,GAAGS,OAAO,CAAC1H,QAAR,IAAoBkH,IAA7B;aAEO,aAAY,UAAA1G,OAAO,EAAI;QAC5B,MAAI,CAACzB,KAAL,CAAWyI,GAAX,CAAeC,gBAAf,sBACKC,OADL;UAEE1H,QAAQ,EAAE,kBAAAqH,QAAQ,EAAI;YACpBJ,EAAE,CAACI,QAAD,CAAF;YACA7G,OAAO,CAAC6G,QAAD,CAAP;;;OALC,CAAP;KAtEK;;;;;;IAoFPtG,KApFO,mBAoFE;WACF6F,cAAL,IAAuB,KAAKA,cAAL,CAAoBlG,OAApB,CAA4B,IAA5B,CAAvB;WACKQ,YAAL;KAtFK;;;;;;IA4FPC,OA5FO,qBA4FI;WACJK,cAAL;WACKoF,cAAL,IAAuB,KAAKA,cAAL,CAAoBlG,OAApB,CAA4B0B,SAA5B,CAAvB;KA9FK;;;;;;IAoGPlB,YApGO,0BAoGS;MACRO,mBAAN;;GAtOS;EAyObK,KAAK;IACH7C,EADG,cACCgD,KADD,EACQ;UACL,CAAC,KAAKlD,KAAN,IAAekD,KAAK,KAAK,KAAKlD,KAAL,CAAW0E,GAAX,CAAe,IAAf,CAA7B,EAAmD;;;;WAI9C1E,KAAL,CAAWwI,GAAX,CAAe,IAAf,EAAqBtF,KAArB;KANC;IAQHa,MARG,kBAQKb,KARL,EAQY;UACT,CAAC,KAAKlD,KAAN,IAAe,KAAKA,KAAL,CAAW8I,YAAX,EAAnB,EAA8C;MAE9C5F,KAAK,GAAG,KAAKrC,eAAL,CAAqBqC,KAArB,CAAR;;UACI,CAACoC,OAAO,CAACpC,KAAD,EAAQ,KAAKwE,qBAAb,CAAZ,EAAiD;aAC1C1H,KAAL,CAAW+I,SAAX,CAAqB7F,KAArB;;KAbD;IAgBHyD,UAhBG,sBAgBSzD,KAhBT,EAgBgB;UACb,CAAC,KAAKlD,KAAN,IAAe,KAAKA,KAAL,CAAW8I,YAAX,EAAnB,EAA8C;;UAE1C5F,KAAK,KAAK,KAAKoE,iBAAnB,EAAsC;aAC/BtH,KAAL,CAAWgJ,aAAX,CAAyB9F,KAAzB;;KApBD;IAuBHc,IAvBG,gBAuBGd,KAvBH,EAuBU;UACP,CAAC,KAAKlD,KAAN,IAAe,KAAKA,KAAL,CAAW8I,YAAX,EAAnB,EAA8C;;UAE1C5F,KAAK,KAAK,KAAK+D,WAAnB,EAAgC;aACzBjH,KAAL,CAAWiJ,OAAX,CAAmB/F,KAAnB;;KA3BD;IA8BH2D,QA9BG,oBA8BO3D,KA9BP,EA8Bc;UACX,CAAC,KAAKlD,KAAN,IAAe,KAAKA,KAAL,CAAW8I,YAAX,EAAnB,EAA8C;;UAE1C5F,KAAK,KAAK,KAAKkE,eAAnB,EAAoC;aAC7BpH,KAAL,CAAWkJ,WAAX,CAAuBhG,KAAvB;;KAlCD;IAqCHqD,OArCG,mBAqCMrD,KArCN,EAqCa;UACV,CAAC,KAAKlD,KAAV,EAAiB;;UAEbkD,KAAK,KAAK,KAAKlD,KAAL,CAAWmJ,UAAX,EAAd,EAAuC;aAChCnJ,KAAL,CAAWoJ,UAAX,CAAsBlG,KAAtB;;KAzCD;IA4CHmD,OA5CG,mBA4CMnD,KA5CN,EA4Ca;UACV,CAAC,KAAKlD,KAAV,EAAiB;;UAEbkD,KAAK,KAAK,KAAKlD,KAAL,CAAWqJ,UAAX,EAAd,EAAuC;aAChCrJ,KAAL,CAAWsJ,UAAX,CAAsBpG,KAAtB;;;KAGDF,YAAY,CAAC,CACd,wBADc,EAEd,mBAFc,EAGd,gBAHc,EAId,QAJc,EAKd,eALc,EAMd,eANc,EAOd,YAPc,EAQd,aARc,EASd,YATc,CAAD,EAUZ;WAAM,YAAY;WACdC,gBAAL;KADC;GAVY,CAnDZ,CAzOQ;EA0SbsG,SAAS,EAAE;IACTC,KADS,mBACA;aACA,KAAKC,IAAZ;;GA5SS;EA+Sb3F,OA/Sa,qBA+SF;IACHU,gBAAN;;CAhTJ;;AAoTA,SAASA,gBAAT,GAA2B;;;2BACD,IAAxB,EAA8B;;;;IAI5BxE,KAAK,EAAE;MACLyE,UAAU,EAAE,IADP;MAELC,GAAG,EAAE;eAAM,MAAI,CAACC,SAAX;;KANqB;IAQ5BkD,cAAc,EAAE;MACdpD,UAAU,EAAE,IADE;MAEdC,GAAG,EAAE;eAAM,MAAI,CAACgF,SAAL,IAAkB,MAAI,CAACA,SAAL,CAAe5G,aAAvC;;;GAVT;;;;;;;;;AAoBF,SAASJ,mBAAT,GAA8B;;;EAC5BkC,OAAO,CAAC,IAAD,CAAP;MAEMC,EAAE,GAAG,OAAO,EAAlB;MACM8B,UAAU,GAAGgD,2BAA2B,CAAC,KAAK3J,KAAN,EAAa,YAAb,EAA2B,IAA3B,EAAiC6E,EAAjC,CAA9C;MACMb,IAAI,GAAG2C,UAAU,CAAC1B,IAAX,CACXM,GAAM,CAAC;WAAO;MACZqE,IAAI,EAAE,MADM;MAEZ1G,KAAK,EAAE,MAAI,CAAClD,KAAL,CAAWmH,OAAX;KAFF;GAAD,CADK,EAKX0C,uBAAuB,CAAC,OAAD,CALZ,CAAb;MAQMC,OAAO,GAAG/E,KAAQ,CACtB4E,2BAA2B,CAAC,KAAK3J,KAAN,EAAa,QAAb,EAAuB,IAAvB,EAA6B6E,EAA7B,EAAiC;WAAM,MAAI,CAAClE,eAAL,CAAqB,MAAI,CAACX,KAAL,CAAWyH,SAAX,EAArB,CAAN;GAAjC,CADL,EAEtBkC,2BAA2B,CAAC,KAAK3J,KAAN,EAAa,UAAb,EAAyB,IAAzB,EAA+B6E,EAA/B,CAFL,EAGtB8B,UAHsB,EAItB3C,IAJsB,CAAxB;OAOK2B,WAAL,CAAiBmE,OAAjB,EAA0B,gBAAqB;QAAlBF,IAAkB,QAAlBA,IAAkB;QAAZ1G,KAAY,QAAZA,KAAY;MAC3C,MAAI,CAACgE,GAAP;;IAEA,MAAI,CAAChF,SAAL,CAAe,YAAM;MACnB,MAAI,CAAC0D,KAAL,kBAAqBgE,IAArB,GAA6B1G,KAA7B;KADF;GAHF;;;AChXU,+BAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACCZ,SAAS6G,MAAT,CAAiBnI,MAAjB,EAAoC;MAAd+G,OAAc,uEAAJ,EAAI;;MAC9BoB,MAAM,CAACC,SAAX,EAAsB;;;;EAGtBD,MAAM,CAACC,SAAP,GAAmB,IAAnB;EAEArB,OAAO,GAAGsB,IAAI,CAACtB,OAAD,EAAU,gBAAV,CAAd;;iBACcrJ,KAAd,EAAmBqJ,OAAnB;;iBACc9G,MAAd,EAAoB8G,OAApB;;EAEA/G,MAAG,CAACsI,SAAJ,CAAc5K,KAAG,CAAClC,IAAlB,EAAwBkC,KAAxB;EACAsC,MAAG,CAACsI,SAAJ,CAAcrI,MAAI,CAACzE,IAAnB,EAAyByE,MAAzB;;;;;;"}