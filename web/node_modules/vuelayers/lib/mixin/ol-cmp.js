/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.21
 * @license MIT
 * @copyright (c) 2017-2020, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _Object$defineProperties from '@babel/runtime-corejs3/core-js-stable/object/define-properties';
import _Promise from '@babel/runtime-corejs3/core-js-stable/promise';
import _regeneratorRuntime from '@babel/runtime-corejs3/regenerator';
import _includesInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/includes';
import _bindInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/bind';
import _asyncToGenerator from '@babel/runtime-corejs3/helpers/esm/asyncToGenerator';
import _filterInstanceProperty from '@babel/runtime-corejs3/core-js-stable/instance/filter';
import debounce from 'debounce-promise';
import { interval } from 'rxjs/_esm5/internal/observable/interval';
import { first } from 'rxjs/_esm5/internal/operators/first';
import { skipWhile } from 'rxjs/_esm5/internal/operators/skipWhile';
import uuid from 'uuid/v4';
import { log } from '../util/log';
import { identity, isFunction } from '../util/minilo';
import identMap from './ident-map';
import rxSubs from './rx-subs';
import services from './services';

var VM_PROP = 'vm';
/**
 * Basic ol component mixin.
 * todo try to subscribe to generic change event here and update rev according to internal ol counter
 */

var olCmp = {
  VM_PROP: VM_PROP,
  mixins: [identMap, rxSubs, services],
  props: {
    id: {
      type: [String, Number],
      default: function _default() {
        return uuid();
      }
    }
  },
  data: function data() {
    return {
      rev: 0
    };
  },
  computed: {
    cmpName: function cmpName() {
      return this.$options.name;
    },
    vmId: function vmId() {
      var _context;

      return _filterInstanceProperty(_context = [this.cmpName, this.id]).call(_context, identity).join('-');
    },
    vmName: function vmName() {
      var _context2;

      return _filterInstanceProperty(_context2 = [this.cmpName, this.id]).call(_context2, identity).join(' ');
    },
    olObjIdent: function olObjIdent() {
      return this.selfIdent;
    }
  },
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit: function beforeInit() {},

    /**
     * @return {Promise<void>} Resolves when initialization completes
     * @protected
     */
    init: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee() {
        var _context3, _context4;

        return _regeneratorRuntime.wrap(function _callee$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.instanceFactoryCall(this.olObjIdent, _bindInstanceProperty(_context3 = this.createOlObject).call(_context3, this));

              case 2:
                this._olObject = _context5.sent;
                this._olObject[VM_PROP] || (this._olObject[VM_PROP] = []);

                if (!_includesInstanceProperty(_context4 = this._olObject[VM_PROP]).call(_context4, this)) {
                  // for loaded from IdentityMap
                  this._olObject[VM_PROP].push(this);
                }

                ++this.rev;

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }(),

    /**
     * @return {module:ol/Object~BaseObject|Promise<module:ol/Object~BaseObject>}
     * @protected
     * @abstract
     */
    createOlObject: function createOlObject() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      var _this = this;

      this.unsetInstances();

      if (this._olObject) {
        var _context6;

        this._olObject[VM_PROP] = _filterInstanceProperty(_context6 = this._olObject[VM_PROP]).call(_context6, function (vm) {
          return vm !== _this;
        });
        this._olObject = undefined;
      }
    },

    /**
     * Redefine for easy call in child components
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return services.methods.getServices.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    mount: function mount() {
      this.subscribeAll();
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();
    },

    /**
     * Refresh internal ol objects
     * @return {Promise<void>}
     */
    refresh: function refresh() {
      var _this2 = this;

      if (this.$olObject == null) return _Promise.resolve();
      return new _Promise(function (resolve) {
        if (_this2.$olObject && isFunction(_this2.$olObject.changed)) {
          _this2.$olObject.once('change', function () {
            return resolve();
          });

          _this2.$olObject.changed();
        } else {
          resolve();
        }
      });
    },

    /**
     * Internal usage only in components that doesn't support refreshing.
     * @return {Promise<void>}
     * @protected
     */
    remount: function () {
      var _remount = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this.$olObject == null)) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return");

              case 2:
                _context7.next = 4;
                return this.unmount();

              case 4:
                _context7.next = 6;
                return this.mount();

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee2, this);
      }));

      function remount() {
        return _remount.apply(this, arguments);
      }

      return remount;
    }(),

    /**
     * Only for internal purpose to support watching for properties
     * for which OpenLayers doesn't provide setters.
     * @return {Promise}
     * @protected
     */
    recreate: function () {
      var _recreate = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!(this.$olObject == null)) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return");

              case 2:
                _context8.next = 4;
                return this.unmount();

              case 4:
                _context8.next = 6;
                return this.deinit();

              case 6:
                _context8.next = 8;
                return this.init();

              case 8:
                _context8.next = 10;
                return this.mount();

              case 10:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee3, this);
      }));

      function recreate() {
        return _recreate.apply(this, arguments);
      }

      return recreate;
    }(),
    subscribeAll: function subscribeAll() {}
  },
  created: function created() {
    var _this3 = this;

    /**
     * @type {module:ol/Object~BaseObject}
     * @private
     */
    this._olObject = undefined;

    _Object$defineProperties(this, {
      $olObject: {
        enumerable: true,
        get: function get() {
          return _this3._olObject;
        }
      }
    });

    defineLifeCyclePromises.call(this);
    defineDebouncedHelpers.call(this);
  },
  mounted: function () {
    var _mounted = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee4() {
      return _regeneratorRuntime.wrap(function _callee4$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.$createPromise;

            case 2:
              this._mounted = true;

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee4, this);
    }));

    function mounted() {
      return _mounted.apply(this, arguments);
    }

    return mounted;
  }(),
  beforeDestroy: function () {
    var _beforeDestroy = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee5() {
      return _regeneratorRuntime.wrap(function _callee5$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.$mountPromise;

            case 2:
              this._mounted = false;

            case 3:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee5, this);
    }));

    function beforeDestroy() {
      return _beforeDestroy.apply(this, arguments);
    }

    return beforeDestroy;
  }(),
  destroyed: function () {
    var _destroyed = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee6() {
      return _regeneratorRuntime.wrap(function _callee6$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.$unmountPromise;

            case 2:
              this._destroyed = true;

            case 3:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee6, this);
    }));

    function destroyed() {
      return _destroyed.apply(this, arguments);
    }

    return destroyed;
  }()
};

function defineLifeCyclePromises() {
  var _this4 = this;

  var makeEventEmitter = function makeEventEmitter(event) {
    return function () {
      _this4.$emit(event, _this4);

      if (process.env.VUELAYERS_DEBUG) {
        log(event, _this4.vmName);
      }

      return _this4;
    };
  }; // create


  this._createPromise = _Promise.resolve(this.beforeInit()).then(function () {
    return _this4.init();
  }).then(makeEventEmitter('created')); // mount

  var mountObs = interval(1000 / 60).pipe(skipWhile(function () {
    return _this4._mounted !== true;
  }), first());
  this._mountPromise = mountObs.toPromise(_Promise).then(function () {
    return _this4.mount();
  }).then(makeEventEmitter('mounted')); // unmount

  var unmountObs = interval(1000 / 60).pipe(skipWhile(function () {
    return _this4._mounted !== false;
  }), first());
  this._unmountPromise = unmountObs.toPromise(_Promise).then(function () {
    return _this4.unmount();
  }).then(makeEventEmitter('unmounted')); // destroy

  var destroyObs = interval(1000 / 60).pipe(skipWhile(function () {
    return _this4._destroyed !== true;
  }), first());
  this._destroyPromise = destroyObs.toPromise(_Promise).then(function () {
    return _this4.deinit();
  }).then(makeEventEmitter('destroyed'));

  _Object$defineProperties(this, {
    $createPromise: {
      enumerable: true,
      get: function get() {
        return _this4._createPromise;
      }
    },
    $mountPromise: {
      enumerable: true,
      get: function get() {
        return _this4._mountPromise;
      }
    },
    $unmountPromise: {
      enumerable: true,
      get: function get() {
        return _this4._unmountPromise;
      }
    },
    $destroyPromise: {
      enumerable: true,
      get: function get() {
        return _this4._destroyPromise;
      }
    }
  });
}

function defineDebouncedHelpers() {
  var t = 1000 / 10; // bind debounced functions at runtime
  // for each instance to avoid interfering between
  // different instances

  this.scheduleRefresh = debounce(function () {
    return this.refresh();
  }, t);
  this.scheduleRemount = debounce(function () {
    return this.remount();
  }, t);
  this.scheduleRecreate = debounce(function () {
    return this.recreate();
  }, t);
}

export default olCmp;
