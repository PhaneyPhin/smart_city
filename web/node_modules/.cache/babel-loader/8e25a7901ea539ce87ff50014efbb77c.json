{"remainingRequest":"C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\node_modules\\@vue\\cli-plugin-babel\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\src\\service\\paho-mqtt.js","dependencies":[{"path":"C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\src\\service\\paho-mqtt.js","mtime":1580033019061},{"path":"C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1579332194156},{"path":"C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\node_modules\\@vue\\cli-plugin-babel\\node_modules\\babel-loader\\lib\\index.js","mtime":1579332188909},{"path":"C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\node_modules\\eslint-loader\\index.js","mtime":1579332204667}],"contextDependencies":[],"result":["import \"core-js/modules/es6.typed.float64-array\";\nimport \"core-js/modules/es6.typed.float32-array\";\nimport \"core-js/modules/es6.typed.uint32-array\";\nimport \"core-js/modules/es6.typed.int32-array\";\nimport \"core-js/modules/es6.typed.uint16-array\";\nimport \"core-js/modules/es6.typed.int16-array\";\nimport \"core-js/modules/es6.typed.int8-array\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport \"core-js/modules/es6.function.name\";\nimport _typeof from \"C:\\\\Users\\\\Sovannarith Phan\\\\Utility_Website\\\\web\\\\node_modules\\\\@babel\\\\runtime/helpers/builtin/es6/typeof\";\n\n/* eslint-disable */\n\n/*******************************************************************************\r\n * Copyright (c) 2013 IBM Corp.\r\n *\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * and Eclipse Distribution License v1.0 which accompany this distribution.\r\n *\r\n * The Eclipse Public License is available at\r\n *    http://www.eclipse.org/legal/epl-v10.html\r\n * and the Eclipse Distribution License is available at\r\n *   http://www.eclipse.org/org/documents/edl-v10.php.\r\n *\r\n * Contributors:\r\n *    Andrew Banks - initial API and implementation and initial documentation\r\n *******************************************************************************/\n// Only expose a single object name in the global namespace.\n// Everything must go through this module. Global Paho.MQTT module\n// only has a single public function, client, which returns\n// a Paho.MQTT client object given connection details.\n\n/**\r\n * Send and receive messages using web browsers.\r\n * <p>\r\n * This programming interface lets a JavaScript client application use the MQTT V3.1 or\r\n * V3.1.1 protocol to connect to an MQTT-supporting messaging server.\r\n *\r\n * The function supported includes:\r\n * <ol>\r\n * <li>Connecting to and disconnecting from a server. The server is identified by its host name and port number.\r\n * <li>Specifying options that relate to the communications link with the server,\r\n * for example the frequency of keep-alive heartbeats, and whether SSL/TLS is required.\r\n * <li>Subscribing to and receiving messages from MQTT Topics.\r\n * <li>Publishing messages to MQTT Topics.\r\n * </ol>\r\n * <p>\r\n * The API consists of two main objects:\r\n * <dl>\r\n * <dt><b>{@link Paho.MQTT.Client}</b></dt>\r\n * <dd>This contains methods that provide the functionality of the API,\r\n * including provision of callbacks that notify the application when a message\r\n * arrives from or is delivered to the messaging server,\r\n * or when the status of its connection to the messaging server changes.</dd>\r\n * <dt><b>{@link Paho.MQTT.Message}</b></dt>\r\n * <dd>This encapsulates the payload of the message along with various attributes\r\n * associated with its delivery, in particular the destination to which it has\r\n * been (or is about to be) sent.</dd>\r\n * </dl>\r\n * <p>\r\n * The programming interface validates parameters passed to it, and will throw\r\n * an Error containing an error message intended for developer use, if it detects\r\n * an error with any parameter.\r\n * <p>\r\n * Example:\r\n *\r\n * <code><pre>\r\nclient = new Paho.MQTT.Client(location.hostname, Number(location.port), \"clientId\");\r\nclient.onConnectionLost = onConnectionLost;\r\nclient.onMessageArrived = onMessageArrived;\r\nclient.connect({onSuccess:onConnect});\r\n\r\nfunction onConnect() {\r\n  // Once a connection has been made, make a subscription and send a message.\r\n  console.log(\"onConnect\");\r\n  client.subscribe(\"/World\");\r\n  message = new Paho.MQTT.Message(\"Hello\");\r\n  message.destinationName = \"/World\";\r\n  client.send(message);\r\n};\r\nfunction onConnectionLost(responseObject) {\r\n  if (responseObject.errorCode !== 0)\r\n    console.log(\"onConnectionLost:\"+responseObject.errorMessage);\r\n};\r\nfunction onMessageArrived(message) {\r\n  console.log(\"onMessageArrived:\"+message.payloadString);\r\n  client.disconnect();\r\n};\r\n * </pre></code>\r\n * @namespace Paho.MQTT\r\n */\n\n/* jshint shadow:true */\n// (function ExportLibrary(root, factory) {\n//  if(typeof exports === 'object' && typeof module === 'object'){\n//      module.exports = factory();\n//  } else if (typeof define === 'function' && define.amd){\n//      define(factory);\n//  } else if (typeof exports === 'object'){\n//      exports = factory();\n//  } else {\n//      if (typeof root.Paho === 'undefined'){\n//          root.Paho = {};\n//      }\n//      root.Paho.MQTT = factory();\n//  }\n// })(this, function LibraryFactory(){\nif (typeof Paho === \"undefined\") {\n  var Paho = {};\n}\n\nPaho.MQTT = function (global) {\n  // Private variables below, these are only visible inside the function closure\n  // which is used to define the module.\n  var version = \"@VERSION@\";\n  var buildLevel = \"@BUILDLEVEL@\";\n  /**\r\n   * Unique message type identifiers, with associated\r\n   * associated integer values.\r\n   * @private\r\n   */\n\n  var MESSAGE_TYPE = {\n    CONNECT: 1,\n    CONNACK: 2,\n    PUBLISH: 3,\n    PUBACK: 4,\n    PUBREC: 5,\n    PUBREL: 6,\n    PUBCOMP: 7,\n    SUBSCRIBE: 8,\n    SUBACK: 9,\n    UNSUBSCRIBE: 10,\n    UNSUBACK: 11,\n    PINGREQ: 12,\n    PINGRESP: 13,\n    DISCONNECT: 14\n  }; // Collection of utility methods used to simplify module code\n  // and promote the DRY pattern.\n\n  /**\r\n   * Validate an object's parameter names to ensure they\r\n   * match a list of expected variables name for this option\r\n   * type. Used to ensure option object passed into the API don't\r\n   * contain erroneous parameters.\r\n   * @param {Object} obj - User options object\r\n   * @param {Object} keys - valid keys and types that may exist in obj.\r\n   * @throws {Error} Invalid option parameter found.\r\n   * @private\r\n   */\n\n  var validate = function validate(obj, keys) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (keys.hasOwnProperty(key)) {\n          if (_typeof(obj[key]) !== keys[key]) throw new Error(format(ERROR.INVALID_TYPE, [_typeof(obj[key]), key]));\n        } else {\n          var errorStr = \"Unknown property, \" + key + \". Valid properties are:\";\n\n          for (var validKey in keys) {\n            if (keys.hasOwnProperty(validKey)) errorStr = errorStr + \" \" + validKey;\n          }\n\n          throw new Error(errorStr);\n        }\n      }\n    }\n  };\n  /**\r\n   * Return a new function which runs the user function bound\r\n   * to a fixed scope.\r\n   * @param {function} User function\r\n   * @param {object} Function scope\r\n   * @return {function} User function bound to another scope\r\n   * @private\r\n   */\n\n\n  var scope = function scope(f, _scope) {\n    return function () {\n      return f.apply(_scope, arguments);\n    };\n  };\n  /**\r\n   * Unique message type identifiers, with associated\r\n   * associated integer values.\r\n   * @private\r\n   */\n\n\n  var ERROR = {\n    OK: {\n      code: 0,\n      text: \"AMQJSC0000I OK.\"\n    },\n    CONNECT_TIMEOUT: {\n      code: 1,\n      text: \"AMQJSC0001E Connect timed out.\"\n    },\n    SUBSCRIBE_TIMEOUT: {\n      code: 2,\n      text: \"AMQJS0002E Subscribe timed out.\"\n    },\n    UNSUBSCRIBE_TIMEOUT: {\n      code: 3,\n      text: \"AMQJS0003E Unsubscribe timed out.\"\n    },\n    PING_TIMEOUT: {\n      code: 4,\n      text: \"AMQJS0004E Ping timed out.\"\n    },\n    INTERNAL_ERROR: {\n      code: 5,\n      text: \"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}\"\n    },\n    CONNACK_RETURNCODE: {\n      code: 6,\n      text: \"AMQJS0006E Bad Connack return code:{0} {1}.\"\n    },\n    SOCKET_ERROR: {\n      code: 7,\n      text: \"AMQJS0007E Socket error:{0}.\"\n    },\n    SOCKET_CLOSE: {\n      code: 8,\n      text: \"AMQJS0008I Socket closed.\"\n    },\n    MALFORMED_UTF: {\n      code: 9,\n      text: \"AMQJS0009E Malformed UTF data:{0} {1} {2}.\"\n    },\n    UNSUPPORTED: {\n      code: 10,\n      text: \"AMQJS0010E {0} is not supported by this browser.\"\n    },\n    INVALID_STATE: {\n      code: 11,\n      text: \"AMQJS0011E Invalid state {0}.\"\n    },\n    INVALID_TYPE: {\n      code: 12,\n      text: \"AMQJS0012E Invalid type {0} for {1}.\"\n    },\n    INVALID_ARGUMENT: {\n      code: 13,\n      text: \"AMQJS0013E Invalid argument {0} for {1}.\"\n    },\n    UNSUPPORTED_OPERATION: {\n      code: 14,\n      text: \"AMQJS0014E Unsupported operation.\"\n    },\n    INVALID_STORED_DATA: {\n      code: 15,\n      text: \"AMQJS0015E Invalid data in local storage key={0} value={1}.\"\n    },\n    INVALID_MQTT_MESSAGE_TYPE: {\n      code: 16,\n      text: \"AMQJS0016E Invalid MQTT message type {0}.\"\n    },\n    MALFORMED_UNICODE: {\n      code: 17,\n      text: \"AMQJS0017E Malformed Unicode string:{0} {1}.\"\n    },\n    BUFFER_FULL: {\n      code: 18,\n      text: \"AMQJS0018E Message buffer is full, maximum buffer size: {0}.\"\n    }\n  };\n  /** CONNACK RC Meaning. */\n\n  var CONNACK_RC = {\n    0: \"Connection Accepted\",\n    1: \"Connection Refused: unacceptable protocol version\",\n    2: \"Connection Refused: identifier rejected\",\n    3: \"Connection Refused: server unavailable\",\n    4: \"Connection Refused: bad user name or password\",\n    5: \"Connection Refused: not authorized\"\n  };\n  /**\r\n   * Format an error message text.\r\n   * @private\r\n   * @param {error} ERROR.KEY value above.\r\n   * @param {substitutions} [array] substituted into the text.\r\n   * @return the text with the substitutions made.\r\n   */\n\n  var format = function format(error, substitutions) {\n    var text = error.text;\n\n    if (substitutions) {\n      var field, start;\n\n      for (var i = 0; i < substitutions.length; i++) {\n        field = \"{\" + i + \"}\";\n        start = text.indexOf(field);\n\n        if (start > 0) {\n          var part1 = text.substring(0, start);\n          var part2 = text.substring(start + field.length);\n          text = part1 + substitutions[i] + part2;\n        }\n      }\n    }\n\n    return text;\n  }; //MQTT protocol and version          6    M    Q    I    s    d    p    3\n\n\n  var MqttProtoIdentifierv3 = [0x00, 0x06, 0x4d, 0x51, 0x49, 0x73, 0x64, 0x70, 0x03]; //MQTT proto/version for 311         4    M    Q    T    T    4\n\n  var MqttProtoIdentifierv4 = [0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04];\n  /**\r\n   * Construct an MQTT wire protocol message.\r\n   * @param type MQTT packet type.\r\n   * @param options optional wire message attributes.\r\n   *\r\n   * Optional properties\r\n   *\r\n   * messageIdentifier: message ID in the range [0..65535]\r\n   * payloadMessage:  Application Message - PUBLISH only\r\n   * connectStrings:  array of 0 or more Strings to be put into the CONNECT payload\r\n   * topics:          array of strings (SUBSCRIBE, UNSUBSCRIBE)\r\n   * requestQoS:      array of QoS values [0..2]\r\n   *\r\n   * \"Flag\" properties\r\n   * cleanSession:    true if present / false if absent (CONNECT)\r\n   * willMessage:     true if present / false if absent (CONNECT)\r\n   * isRetained:      true if present / false if absent (CONNECT)\r\n   * userName:        true if present / false if absent (CONNECT)\r\n   * password:        true if present / false if absent (CONNECT)\r\n   * keepAliveInterval:   integer [0..65535]  (CONNECT)\r\n   *\r\n   * @private\r\n   * @ignore\r\n   */\n\n  var WireMessage = function WireMessage(type, options) {\n    this.type = type;\n\n    for (var name in options) {\n      if (options.hasOwnProperty(name)) {\n        this[name] = options[name];\n      }\n    }\n  };\n\n  WireMessage.prototype.encode = function () {\n    // Compute the first byte of the fixed header\n    var first = (this.type & 0x0f) << 4;\n    /*\r\n     * Now calculate the length of the variable header + payload by adding up the lengths\r\n     * of all the component parts\r\n     */\n\n    var remLength = 0;\n    var topicStrLength = [];\n    var destinationNameLength = 0;\n    var willMessagePayloadBytes; // if the message contains a messageIdentifier then we need two bytes for that\n\n    if (this.messageIdentifier !== undefined) remLength += 2;\n\n    switch (this.type) {\n      // If this a Connect then we need to include 12 bytes for its header\n      case MESSAGE_TYPE.CONNECT:\n        switch (this.mqttVersion) {\n          case 3:\n            remLength += MqttProtoIdentifierv3.length + 3;\n            break;\n\n          case 4:\n            remLength += MqttProtoIdentifierv4.length + 3;\n            break;\n        }\n\n        remLength += UTF8Length(this.clientId) + 2;\n\n        if (this.willMessage !== undefined) {\n          remLength += UTF8Length(this.willMessage.destinationName) + 2; // Will message is always a string, sent as UTF-8 characters with a preceding length.\n\n          willMessagePayloadBytes = this.willMessage.payloadBytes;\n          if (!(willMessagePayloadBytes instanceof Uint8Array)) willMessagePayloadBytes = new Uint8Array(payloadBytes);\n          remLength += willMessagePayloadBytes.byteLength + 2;\n        }\n\n        if (this.userName !== undefined) remLength += UTF8Length(this.userName) + 2;\n        if (this.password !== undefined) remLength += UTF8Length(this.password) + 2;\n        break;\n      // Subscribe, Unsubscribe can both contain topic strings\n\n      case MESSAGE_TYPE.SUBSCRIBE:\n        first |= 0x02; // Qos = 1;\n\n        for (var i = 0; i < this.topics.length; i++) {\n          topicStrLength[i] = UTF8Length(this.topics[i]);\n          remLength += topicStrLength[i] + 2;\n        }\n\n        remLength += this.requestedQos.length; // 1 byte for each topic's Qos\n        // QoS on Subscribe only\n\n        break;\n\n      case MESSAGE_TYPE.UNSUBSCRIBE:\n        first |= 0x02; // Qos = 1;\n\n        for (var i = 0; i < this.topics.length; i++) {\n          topicStrLength[i] = UTF8Length(this.topics[i]);\n          remLength += topicStrLength[i] + 2;\n        }\n\n        break;\n\n      case MESSAGE_TYPE.PUBREL:\n        first |= 0x02; // Qos = 1;\n\n        break;\n\n      case MESSAGE_TYPE.PUBLISH:\n        if (this.payloadMessage.duplicate) first |= 0x08;\n        first = first |= this.payloadMessage.qos << 1;\n        if (this.payloadMessage.retained) first |= 0x01;\n        destinationNameLength = UTF8Length(this.payloadMessage.destinationName);\n        remLength += destinationNameLength + 2;\n        var payloadBytes = this.payloadMessage.payloadBytes;\n        remLength += payloadBytes.byteLength;\n        if (payloadBytes instanceof ArrayBuffer) payloadBytes = new Uint8Array(payloadBytes);else if (!(payloadBytes instanceof Uint8Array)) payloadBytes = new Uint8Array(payloadBytes.buffer);\n        break;\n\n      case MESSAGE_TYPE.DISCONNECT:\n        break;\n\n      default:\n        break;\n    } // Now we can allocate a buffer for the message\n\n\n    var mbi = encodeMBI(remLength); // Convert the length to MQTT MBI format\n\n    var pos = mbi.length + 1; // Offset of start of variable header\n\n    var buffer = new ArrayBuffer(remLength + pos);\n    var byteStream = new Uint8Array(buffer); // view it as a sequence of bytes\n    //Write the fixed header into the buffer\n\n    byteStream[0] = first;\n    byteStream.set(mbi, 1); // If this is a PUBLISH then the variable header starts with a topic\n\n    if (this.type == MESSAGE_TYPE.PUBLISH) pos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos); // If this is a CONNECT then the variable header contains the protocol name/version, flags and keepalive time\n    else if (this.type == MESSAGE_TYPE.CONNECT) {\n        switch (this.mqttVersion) {\n          case 3:\n            byteStream.set(MqttProtoIdentifierv3, pos);\n            pos += MqttProtoIdentifierv3.length;\n            break;\n\n          case 4:\n            byteStream.set(MqttProtoIdentifierv4, pos);\n            pos += MqttProtoIdentifierv4.length;\n            break;\n        }\n\n        var connectFlags = 0;\n        if (this.cleanSession) connectFlags = 0x02;\n\n        if (this.willMessage !== undefined) {\n          connectFlags |= 0x04;\n          connectFlags |= this.willMessage.qos << 3;\n\n          if (this.willMessage.retained) {\n            connectFlags |= 0x20;\n          }\n        }\n\n        if (this.userName !== undefined) connectFlags |= 0x80;\n        if (this.password !== undefined) connectFlags |= 0x40;\n        byteStream[pos++] = connectFlags;\n        pos = writeUint16(this.keepAliveInterval, byteStream, pos);\n      } // Output the messageIdentifier - if there is one\n\n    if (this.messageIdentifier !== undefined) pos = writeUint16(this.messageIdentifier, byteStream, pos);\n\n    switch (this.type) {\n      case MESSAGE_TYPE.CONNECT:\n        pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);\n\n        if (this.willMessage !== undefined) {\n          pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);\n          pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\n          byteStream.set(willMessagePayloadBytes, pos);\n          pos += willMessagePayloadBytes.byteLength;\n        }\n\n        if (this.userName !== undefined) pos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);\n        if (this.password !== undefined) pos = writeString(this.password, UTF8Length(this.password), byteStream, pos);\n        break;\n\n      case MESSAGE_TYPE.PUBLISH:\n        // PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\n        byteStream.set(payloadBytes, pos);\n        break;\n      //          case MESSAGE_TYPE.PUBREC:\n      //          case MESSAGE_TYPE.PUBREL:\n      //          case MESSAGE_TYPE.PUBCOMP:\n      //              break;\n\n      case MESSAGE_TYPE.SUBSCRIBE:\n        // SUBSCRIBE has a list of topic strings and request QoS\n        for (var i = 0; i < this.topics.length; i++) {\n          pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n          byteStream[pos++] = this.requestedQos[i];\n        }\n\n        break;\n\n      case MESSAGE_TYPE.UNSUBSCRIBE:\n        // UNSUBSCRIBE has a list of topic strings\n        for (var i = 0; i < this.topics.length; i++) {\n          pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n        }\n\n        break;\n\n      default: // Do nothing.\n\n    }\n\n    return buffer;\n  };\n\n  function decodeMessage(input, pos) {\n    var startingPos = pos;\n    var first = input[pos];\n    var type = first >> 4;\n    var messageInfo = first &= 0x0f;\n    pos += 1; // Decode the remaining length (MBI format)\n\n    var digit;\n    var remLength = 0;\n    var multiplier = 1;\n\n    do {\n      if (pos == input.length) {\n        return [null, startingPos];\n      }\n\n      digit = input[pos++];\n      remLength += (digit & 0x7F) * multiplier;\n      multiplier *= 128;\n    } while ((digit & 0x80) !== 0);\n\n    var endPos = pos + remLength;\n\n    if (endPos > input.length) {\n      return [null, startingPos];\n    }\n\n    var wireMessage = new WireMessage(type);\n\n    switch (type) {\n      case MESSAGE_TYPE.CONNACK:\n        var connectAcknowledgeFlags = input[pos++];\n        if (connectAcknowledgeFlags & 0x01) wireMessage.sessionPresent = true;\n        wireMessage.returnCode = input[pos++];\n        break;\n\n      case MESSAGE_TYPE.PUBLISH:\n        var qos = messageInfo >> 1 & 0x03;\n        var len = readUint16(input, pos);\n        pos += 2;\n        var topicName = parseUTF8(input, pos, len);\n        pos += len; // If QoS 1 or 2 there will be a messageIdentifier\n\n        if (qos > 0) {\n          wireMessage.messageIdentifier = readUint16(input, pos);\n          pos += 2;\n        }\n\n        var message = new Paho.MQTT.Message(input.subarray(pos, endPos));\n        if ((messageInfo & 0x01) == 0x01) message.retained = true;\n        if ((messageInfo & 0x08) == 0x08) message.duplicate = true;\n        message.qos = qos;\n        message.destinationName = topicName;\n        wireMessage.payloadMessage = message;\n        break;\n\n      case MESSAGE_TYPE.PUBACK:\n      case MESSAGE_TYPE.PUBREC:\n      case MESSAGE_TYPE.PUBREL:\n      case MESSAGE_TYPE.PUBCOMP:\n      case MESSAGE_TYPE.UNSUBACK:\n        wireMessage.messageIdentifier = readUint16(input, pos);\n        break;\n\n      case MESSAGE_TYPE.SUBACK:\n        wireMessage.messageIdentifier = readUint16(input, pos);\n        pos += 2;\n        wireMessage.returnCode = input.subarray(pos, endPos);\n        break;\n\n      default:\n        break;\n    }\n\n    return [wireMessage, endPos];\n  }\n\n  function writeUint16(input, buffer, offset) {\n    buffer[offset++] = input >> 8; //MSB\n\n    buffer[offset++] = input % 256; //LSB\n\n    return offset;\n  }\n\n  function writeString(input, utf8Length, buffer, offset) {\n    offset = writeUint16(utf8Length, buffer, offset);\n    stringToUTF8(input, buffer, offset);\n    return offset + utf8Length;\n  }\n\n  function readUint16(buffer, offset) {\n    return 256 * buffer[offset] + buffer[offset + 1];\n  }\n  /**\r\n   * Encodes an MQTT Multi-Byte Integer\r\n   * @private\r\n   */\n\n\n  function encodeMBI(number) {\n    var output = new Array(1);\n    var numBytes = 0;\n\n    do {\n      var digit = number % 128;\n      number = number >> 7;\n\n      if (number > 0) {\n        digit |= 0x80;\n      }\n\n      output[numBytes++] = digit;\n    } while (number > 0 && numBytes < 4);\n\n    return output;\n  }\n  /**\r\n   * Takes a String and calculates its length in bytes when encoded in UTF8.\r\n   * @private\r\n   */\n\n\n  function UTF8Length(input) {\n    var output = 0;\n\n    for (var i = 0; i < input.length; i++) {\n      var charCode = input.charCodeAt(i);\n\n      if (charCode > 0x7FF) {\n        // Surrogate pair means its a 4 byte character\n        if (0xD800 <= charCode && charCode <= 0xDBFF) {\n          i++;\n          output++;\n        }\n\n        output += 3;\n      } else if (charCode > 0x7F) output += 2;else output++;\n    }\n\n    return output;\n  }\n  /**\r\n   * Takes a String and writes it into an array as UTF8 encoded bytes.\r\n   * @private\r\n   */\n\n\n  function stringToUTF8(input, output, start) {\n    var pos = start;\n\n    for (var i = 0; i < input.length; i++) {\n      var charCode = input.charCodeAt(i); // Check for a surrogate pair.\n\n      if (0xD800 <= charCode && charCode <= 0xDBFF) {\n        var lowCharCode = input.charCodeAt(++i);\n\n        if (isNaN(lowCharCode)) {\n          throw new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));\n        }\n\n        charCode = (charCode - 0xD800 << 10) + (lowCharCode - 0xDC00) + 0x10000;\n      }\n\n      if (charCode <= 0x7F) {\n        output[pos++] = charCode;\n      } else if (charCode <= 0x7FF) {\n        output[pos++] = charCode >> 6 & 0x1F | 0xC0;\n        output[pos++] = charCode & 0x3F | 0x80;\n      } else if (charCode <= 0xFFFF) {\n        output[pos++] = charCode >> 12 & 0x0F | 0xE0;\n        output[pos++] = charCode >> 6 & 0x3F | 0x80;\n        output[pos++] = charCode & 0x3F | 0x80;\n      } else {\n        output[pos++] = charCode >> 18 & 0x07 | 0xF0;\n        output[pos++] = charCode >> 12 & 0x3F | 0x80;\n        output[pos++] = charCode >> 6 & 0x3F | 0x80;\n        output[pos++] = charCode & 0x3F | 0x80;\n      }\n    }\n\n    return output;\n  }\n\n  function parseUTF8(input, offset, length) {\n    var output = \"\";\n    var utf16;\n    var pos = offset;\n\n    while (pos < offset + length) {\n      var byte1 = input[pos++];\n      if (byte1 < 128) utf16 = byte1;else {\n        var byte2 = input[pos++] - 128;\n        if (byte2 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), \"\"]));\n        if (byte1 < 0xE0) // 2 byte character\n          utf16 = 64 * (byte1 - 0xC0) + byte2;else {\n          var byte3 = input[pos++] - 128;\n          if (byte3 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));\n          if (byte1 < 0xF0) // 3 byte character\n            utf16 = 4096 * (byte1 - 0xE0) + 64 * byte2 + byte3;else {\n            var byte4 = input[pos++] - 128;\n            if (byte4 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n            if (byte1 < 0xF8) // 4 byte character\n              utf16 = 262144 * (byte1 - 0xF0) + 4096 * byte2 + 64 * byte3 + byte4;else // longer encodings are not supported\n              throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n          }\n        }\n      }\n\n      if (utf16 > 0xFFFF) // 4 byte character - express as a surrogate pair\n        {\n          utf16 -= 0x10000;\n          output += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character\n\n          utf16 = 0xDC00 + (utf16 & 0x3FF); // trail character\n        }\n\n      output += String.fromCharCode(utf16);\n    }\n\n    return output;\n  }\n  /**\r\n   * Repeat keepalive requests, monitor responses.\r\n   * @ignore\r\n   */\n\n\n  var Pinger = function Pinger(client, window, keepAliveInterval) {\n    this._client = client;\n    this._window = window;\n    this._keepAliveInterval = keepAliveInterval * 1000;\n    this.isReset = false;\n    var pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();\n\n    var doTimeout = function doTimeout(pinger) {\n      return function () {\n        return doPing.apply(pinger);\n      };\n    };\n    /** @ignore */\n\n\n    var doPing = function doPing() {\n      if (!this.isReset) {\n        this._client._trace(\"Pinger.doPing\", \"Timed out\");\n\n        this._client._disconnected(ERROR.PING_TIMEOUT.code, format(ERROR.PING_TIMEOUT));\n      } else {\n        this.isReset = false;\n\n        this._client._trace(\"Pinger.doPing\", \"send PINGREQ\");\n\n        this._client.socket.send(pingReq);\n\n        this.timeout = this._window.setTimeout(doTimeout(this), this._keepAliveInterval);\n      }\n    };\n\n    this.reset = function () {\n      this.isReset = true;\n\n      this._window.clearTimeout(this.timeout);\n\n      if (this._keepAliveInterval > 0) this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\n    };\n\n    this.cancel = function () {\n      this._window.clearTimeout(this.timeout);\n    };\n  };\n  /**\r\n   * Monitor request completion.\r\n   * @ignore\r\n   */\n\n\n  var Timeout = function Timeout(client, window, timeoutSeconds, action, args) {\n    this._window = window;\n    if (!timeoutSeconds) timeoutSeconds = 30;\n\n    var doTimeout = function doTimeout(action, client, args) {\n      return function () {\n        return action.apply(client, args);\n      };\n    };\n\n    this.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);\n\n    this.cancel = function () {\n      this._window.clearTimeout(this.timeout);\n    };\n  };\n  /*\r\n   * Internal implementation of the Websockets MQTT V3.1 client.\r\n   *\r\n   * @name Paho.MQTT.ClientImpl @constructor\r\n   * @param {String} host the DNS nameof the webSocket host.\r\n   * @param {Number} port the port number for that host.\r\n   * @param {String} clientId the MQ client identifier.\r\n   */\n\n\n  var ClientImpl = function ClientImpl(uri, host, port, path, clientId) {\n    // Check dependencies are satisfied in this browser.\n    if (!(\"WebSocket\" in global && global.WebSocket !== null)) {\n      throw new Error(format(ERROR.UNSUPPORTED, [\"WebSocket\"]));\n    }\n\n    if (!(\"localStorage\" in global && global.localStorage !== null)) {\n      throw new Error(format(ERROR.UNSUPPORTED, [\"localStorage\"]));\n    }\n\n    if (!(\"ArrayBuffer\" in global && global.ArrayBuffer !== null)) {\n      throw new Error(format(ERROR.UNSUPPORTED, [\"ArrayBuffer\"]));\n    }\n\n    this._trace(\"Paho.MQTT.Client\", uri, host, port, path, clientId);\n\n    this.host = host;\n    this.port = port;\n    this.path = path;\n    this.uri = uri;\n    this.clientId = clientId;\n    this._wsuri = null; // Local storagekeys are qualified with the following string.\n    // The conditional inclusion of path in the key is for backward\n    // compatibility to when the path was not configurable and assumed to\n    // be /mqtt\n\n    this._localKey = host + \":\" + port + (path != \"/mqtt\" ? \":\" + path : \"\") + \":\" + clientId + \":\"; // Create private instance-only message queue\n    // Internal queue of messages to be sent, in sending order.\n\n    this._msg_queue = [];\n    this._buffered_msg_queue = []; // Messages we have sent and are expecting a response for, indexed by their respective message ids.\n\n    this._sentMessages = {}; // Messages we have received and acknowleged and are expecting a confirm message for\n    // indexed by their respective message ids.\n\n    this._receivedMessages = {}; // Internal list of callbacks to be executed when messages\n    // have been successfully sent over web socket, e.g. disconnect\n    // when it doesn't have to wait for ACK, just message is dispatched.\n\n    this._notify_msg_sent = {}; // Unique identifier for SEND messages, incrementing\n    // counter as messages are sent.\n\n    this._message_identifier = 1; // Used to determine the transmission sequence of stored sent messages.\n\n    this._sequence = 0; // Load the local state, if any, from the saved version, only restore state relevant to this client.\n\n    for (var key in localStorage) {\n      if (key.indexOf(\"Sent:\" + this._localKey) === 0 || key.indexOf(\"Received:\" + this._localKey) === 0) this.restore(key);\n    }\n  }; // Messaging Client public instance members.\n\n\n  ClientImpl.prototype.host = null;\n  ClientImpl.prototype.port = null;\n  ClientImpl.prototype.path = null;\n  ClientImpl.prototype.uri = null;\n  ClientImpl.prototype.clientId = null; // Messaging Client private instance members.\n\n  ClientImpl.prototype.socket = null;\n  /* true once we have received an acknowledgement to a CONNECT packet. */\n\n  ClientImpl.prototype.connected = false;\n  /* The largest message identifier allowed, may not be larger than 2**16 but\r\n   * if set smaller reduces the maximum number of outbound messages allowed.\r\n   */\n\n  ClientImpl.prototype.maxMessageIdentifier = 65536;\n  ClientImpl.prototype.connectOptions = null;\n  ClientImpl.prototype.hostIndex = null;\n  ClientImpl.prototype.onConnected = null;\n  ClientImpl.prototype.onConnectionLost = null;\n  ClientImpl.prototype.onMessageDelivered = null;\n  ClientImpl.prototype.onMessageArrived = null;\n  ClientImpl.prototype.traceFunction = null;\n  ClientImpl.prototype._msg_queue = null;\n  ClientImpl.prototype._buffered_msg_queue = null;\n  ClientImpl.prototype._connectTimeout = null;\n  /* The sendPinger monitors how long we allow before we send data to prove to the server that we are alive. */\n\n  ClientImpl.prototype.sendPinger = null;\n  /* The receivePinger monitors how long we allow before we require evidence that the server is alive. */\n\n  ClientImpl.prototype.receivePinger = null;\n  ClientImpl.prototype._reconnectInterval = 1; // Reconnect Delay, starts at 1 second\n\n  ClientImpl.prototype._reconnecting = false;\n  ClientImpl.prototype._reconnectTimeout = null;\n  ClientImpl.prototype.disconnectedPublishing = false;\n  ClientImpl.prototype.disconnectedBufferSize = 5000;\n  ClientImpl.prototype.receiveBuffer = null;\n  ClientImpl.prototype._traceBuffer = null;\n  ClientImpl.prototype._MAX_TRACE_ENTRIES = 100;\n\n  ClientImpl.prototype.connect = function (connectOptions) {\n    var connectOptionsMasked = this._traceMask(connectOptions, \"password\");\n\n    this._trace(\"Client.connect\", connectOptionsMasked, this.socket, this.connected);\n\n    if (this.connected) throw new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n    if (this.socket) throw new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n\n    if (this._reconnecting) {\n      // connect() function is called while reconnect is in progress.\n      // Terminate the auto reconnect process to use new connect options.\n      this._reconnectTimeout.cancel();\n\n      this._reconnectTimeout = null;\n      this._reconnecting = false;\n    }\n\n    this.connectOptions = connectOptions;\n    this._reconnectInterval = 1;\n    this._reconnecting = false;\n\n    if (connectOptions.uris) {\n      this.hostIndex = 0;\n\n      this._doConnect(connectOptions.uris[0]);\n    } else {\n      this._doConnect(this.uri);\n    }\n  };\n\n  ClientImpl.prototype.subscribe = function (filter, subscribeOptions) {\n    this._trace(\"Client.subscribe\", filter, subscribeOptions);\n\n    if (!this.connected) throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n    var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\n    wireMessage.topics = [filter];\n    if (subscribeOptions.qos !== undefined) wireMessage.requestedQos = [subscribeOptions.qos];else wireMessage.requestedQos = [0];\n\n    if (subscribeOptions.onSuccess) {\n      wireMessage.onSuccess = function (grantedQos) {\n        subscribeOptions.onSuccess({\n          invocationContext: subscribeOptions.invocationContext,\n          grantedQos: grantedQos\n        });\n      };\n    }\n\n    if (subscribeOptions.onFailure) {\n      wireMessage.onFailure = function (errorCode) {\n        subscribeOptions.onFailure({\n          invocationContext: subscribeOptions.invocationContext,\n          errorCode: errorCode,\n          errorMessage: format(errorCode)\n        });\n      };\n    }\n\n    if (subscribeOptions.timeout) {\n      wireMessage.timeOut = new Timeout(this, window, subscribeOptions.timeout, subscribeOptions.onFailure, [{\n        invocationContext: subscribeOptions.invocationContext,\n        errorCode: ERROR.SUBSCRIBE_TIMEOUT.code,\n        errorMessage: format(ERROR.SUBSCRIBE_TIMEOUT)\n      }]);\n    } // All subscriptions return a SUBACK.\n\n\n    this._requires_ack(wireMessage);\n\n    this._schedule_message(wireMessage);\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype.unsubscribe = function (filter, unsubscribeOptions) {\n    this._trace(\"Client.unsubscribe\", filter, unsubscribeOptions);\n\n    if (!this.connected) throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n    var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\n    wireMessage.topics = [filter];\n\n    if (unsubscribeOptions.onSuccess) {\n      wireMessage.callback = function () {\n        unsubscribeOptions.onSuccess({\n          invocationContext: unsubscribeOptions.invocationContext\n        });\n      };\n    }\n\n    if (unsubscribeOptions.timeout) {\n      wireMessage.timeOut = new Timeout(this, window, unsubscribeOptions.timeout, unsubscribeOptions.onFailure, [{\n        invocationContext: unsubscribeOptions.invocationContext,\n        errorCode: ERROR.UNSUBSCRIBE_TIMEOUT.code,\n        errorMessage: format(ERROR.UNSUBSCRIBE_TIMEOUT)\n      }]);\n    } // All unsubscribes return a SUBACK.\n\n\n    this._requires_ack(wireMessage);\n\n    this._schedule_message(wireMessage);\n  };\n\n  ClientImpl.prototype.send = function (message) {\n    this._trace(\"Client.send\", message);\n\n    var wireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);\n    wireMessage.payloadMessage = message;\n\n    if (this.connected) {\n      // Mark qos 1 & 2 message as \"ACK required\"\n      // For qos 0 message, invoke onMessageDelivered callback if there is one.\n      // Then schedule the message.\n      if (message.qos > 0) {\n        this._requires_ack(wireMessage);\n      } else if (this.onMessageDelivered) {\n        this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);\n      }\n\n      this._schedule_message(wireMessage);\n    } else {\n      // Currently disconnected, will not schedule this message\n      // Check if reconnecting is in progress and disconnected publish is enabled.\n      if (this._reconnecting && this.disconnectedPublishing) {\n        // Check the limit which include the \"required ACK\" messages\n        var messageCount = Object.keys(this._sentMessages).length + this._buffered_msg_queue.length;\n\n        if (messageCount > this.disconnectedBufferSize) {\n          throw new Error(format(ERROR.BUFFER_FULL, [this.disconnectedBufferSize]));\n        } else {\n          if (message.qos > 0) {\n            // Mark this message as \"ACK required\"\n            this._requires_ack(wireMessage);\n          } else {\n            wireMessage.sequence = ++this._sequence;\n\n            this._buffered_msg_queue.push(wireMessage);\n          }\n        }\n      } else {\n        throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n      }\n    }\n  };\n\n  ClientImpl.prototype.disconnect = function () {\n    this._trace(\"Client.disconnect\");\n\n    if (this._reconnecting) {\n      // disconnect() function is called while reconnect is in progress.\n      // Terminate the auto reconnect process.\n      this._reconnectTimeout.cancel();\n\n      this._reconnectTimeout = null;\n      this._reconnecting = false;\n    }\n\n    if (!this.socket) throw new Error(format(ERROR.INVALID_STATE, [\"not connecting or connected\"]));\n    wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT); // Run the disconnected call back as soon as the message has been sent,\n    // in case of a failure later on in the disconnect processing.\n    // as a consequence, the _disconected call back may be run several times.\n\n    this._notify_msg_sent[wireMessage] = scope(this._disconnected, this);\n\n    this._schedule_message(wireMessage);\n  };\n\n  ClientImpl.prototype.getTraceLog = function () {\n    if (this._traceBuffer !== null) {\n      this._trace(\"Client.getTraceLog\", new Date());\n\n      this._trace(\"Client.getTraceLog in flight messages\", this._sentMessages.length);\n\n      for (var key in this._sentMessages) {\n        this._trace(\"_sentMessages \", key, this._sentMessages[key]);\n      }\n\n      for (var key in this._receivedMessages) {\n        this._trace(\"_receivedMessages \", key, this._receivedMessages[key]);\n      }\n\n      return this._traceBuffer;\n    }\n  };\n\n  ClientImpl.prototype.startTrace = function () {\n    if (this._traceBuffer === null) {\n      this._traceBuffer = [];\n    }\n\n    this._trace(\"Client.startTrace\", new Date(), version);\n  };\n\n  ClientImpl.prototype.stopTrace = function () {\n    delete this._traceBuffer;\n  };\n\n  ClientImpl.prototype._doConnect = function (wsurl) {\n    // When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.\n    if (this.connectOptions.useSSL) {\n      var uriParts = wsurl.split(\":\");\n      uriParts[0] = \"wss\";\n      wsurl = uriParts.join(\":\");\n    }\n\n    this._wsuri = wsurl;\n    this.connected = false;\n\n    if (this.connectOptions.mqttVersion < 4) {\n      this.socket = new WebSocket(wsurl, [\"mqttv3.1\"]);\n    } else {\n      this.socket = new WebSocket(wsurl, [\"mqtt\"]);\n    }\n\n    this.socket.binaryType = 'arraybuffer';\n    this.socket.onopen = scope(this._on_socket_open, this);\n    this.socket.onmessage = scope(this._on_socket_message, this);\n    this.socket.onerror = scope(this._on_socket_error, this);\n    this.socket.onclose = scope(this._on_socket_close, this);\n    this.sendPinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\n    this.receivePinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\n\n    if (this._connectTimeout) {\n      this._connectTimeout.cancel();\n\n      this._connectTimeout = null;\n    }\n\n    this._connectTimeout = new Timeout(this, window, this.connectOptions.timeout, this._disconnected, [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);\n  }; // Schedule a new message to be sent over the WebSockets\n  // connection. CONNECT messages cause WebSocket connection\n  // to be started. All other messages are queued internally\n  // until this has happened. When WS connection starts, process\n  // all outstanding messages.\n\n\n  ClientImpl.prototype._schedule_message = function (message) {\n    this._msg_queue.push(message); // Process outstanding messages in the queue if we have an  open socket, and have received CONNACK.\n\n\n    if (this.connected) {\n      this._process_queue();\n    }\n  };\n\n  ClientImpl.prototype.store = function (prefix, wireMessage) {\n    var storedMessage = {\n      type: wireMessage.type,\n      messageIdentifier: wireMessage.messageIdentifier,\n      version: 1\n    };\n\n    switch (wireMessage.type) {\n      case MESSAGE_TYPE.PUBLISH:\n        if (wireMessage.pubRecReceived) storedMessage.pubRecReceived = true; // Convert the payload to a hex string.\n\n        storedMessage.payloadMessage = {};\n        var hex = \"\";\n        var messageBytes = wireMessage.payloadMessage.payloadBytes;\n\n        for (var i = 0; i < messageBytes.length; i++) {\n          if (messageBytes[i] <= 0xF) hex = hex + \"0\" + messageBytes[i].toString(16);else hex = hex + messageBytes[i].toString(16);\n        }\n\n        storedMessage.payloadMessage.payloadHex = hex;\n        storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;\n        storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;\n        if (wireMessage.payloadMessage.duplicate) storedMessage.payloadMessage.duplicate = true;\n        if (wireMessage.payloadMessage.retained) storedMessage.payloadMessage.retained = true; // Add a sequence number to sent messages.\n\n        if (prefix.indexOf(\"Sent:\") === 0) {\n          if (wireMessage.sequence === undefined) wireMessage.sequence = ++this._sequence;\n          storedMessage.sequence = wireMessage.sequence;\n        }\n\n        break;\n\n      default:\n        throw Error(format(ERROR.INVALID_STORED_DATA, [key, storedMessage]));\n    }\n\n    localStorage.setItem(prefix + this._localKey + wireMessage.messageIdentifier, JSON.stringify(storedMessage));\n  };\n\n  ClientImpl.prototype.restore = function (key) {\n    var value = localStorage.getItem(key);\n    var storedMessage = JSON.parse(value);\n    var wireMessage = new WireMessage(storedMessage.type, storedMessage);\n\n    switch (storedMessage.type) {\n      case MESSAGE_TYPE.PUBLISH:\n        // Replace the payload message with a Message object.\n        var hex = storedMessage.payloadMessage.payloadHex;\n        var buffer = new ArrayBuffer(hex.length / 2);\n        var byteStream = new Uint8Array(buffer);\n        var i = 0;\n\n        while (hex.length >= 2) {\n          var x = parseInt(hex.substring(0, 2), 16);\n          hex = hex.substring(2, hex.length);\n          byteStream[i++] = x;\n        }\n\n        var payloadMessage = new Paho.MQTT.Message(byteStream);\n        payloadMessage.qos = storedMessage.payloadMessage.qos;\n        payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\n        if (storedMessage.payloadMessage.duplicate) payloadMessage.duplicate = true;\n        if (storedMessage.payloadMessage.retained) payloadMessage.retained = true;\n        wireMessage.payloadMessage = payloadMessage;\n        break;\n\n      default:\n        throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\n    }\n\n    if (key.indexOf(\"Sent:\" + this._localKey) === 0) {\n      wireMessage.payloadMessage.duplicate = true;\n      this._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n    } else if (key.indexOf(\"Received:\" + this._localKey) === 0) {\n      this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n    }\n  };\n\n  ClientImpl.prototype._process_queue = function () {\n    var message = null; // Process messages in order they were added\n\n    var fifo = this._msg_queue.reverse(); // Send all queued messages down socket connection\n\n\n    while (message = fifo.pop()) {\n      this._socket_send(message); // Notify listeners that message was successfully sent\n\n\n      if (this._notify_msg_sent[message]) {\n        this._notify_msg_sent[message]();\n\n        delete this._notify_msg_sent[message];\n      }\n    }\n  };\n  /**\r\n   * Expect an ACK response for this message. Add message to the set of in progress\r\n   * messages and set an unused identifier in this message.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._requires_ack = function (wireMessage) {\n    var messageCount = Object.keys(this._sentMessages).length;\n    if (messageCount > this.maxMessageIdentifier) throw Error(\"Too many messages:\" + messageCount);\n\n    while (this._sentMessages[this._message_identifier] !== undefined) {\n      this._message_identifier++;\n    }\n\n    wireMessage.messageIdentifier = this._message_identifier;\n    this._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n\n    if (wireMessage.type === MESSAGE_TYPE.PUBLISH) {\n      this.store(\"Sent:\", wireMessage);\n    }\n\n    if (this._message_identifier === this.maxMessageIdentifier) {\n      this._message_identifier = 1;\n    }\n  };\n  /**\r\n   * Called when the underlying websocket has been opened.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._on_socket_open = function () {\n    // Create the CONNECT message object.\n    var wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);\n    wireMessage.clientId = this.clientId;\n\n    this._socket_send(wireMessage);\n  };\n  /**\r\n   * Called when the underlying websocket has received a complete packet.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._on_socket_message = function (event) {\n    this._trace(\"Client._on_socket_message\", event.data);\n\n    var messages = this._deframeMessages(event.data);\n\n    for (var i = 0; i < messages.length; i += 1) {\n      this._handleMessage(messages[i]);\n    }\n  };\n\n  ClientImpl.prototype._deframeMessages = function (data) {\n    var byteArray = new Uint8Array(data);\n    var messages = [];\n\n    if (this.receiveBuffer) {\n      var newData = new Uint8Array(this.receiveBuffer.length + byteArray.length);\n      newData.set(this.receiveBuffer);\n      newData.set(byteArray, this.receiveBuffer.length);\n      byteArray = newData;\n      delete this.receiveBuffer;\n    }\n\n    try {\n      var offset = 0;\n\n      while (offset < byteArray.length) {\n        var result = decodeMessage(byteArray, offset);\n        var wireMessage = result[0];\n        offset = result[1];\n\n        if (wireMessage !== null) {\n          messages.push(wireMessage);\n        } else {\n          break;\n        }\n      }\n\n      if (offset < byteArray.length) {\n        this.receiveBuffer = byteArray.subarray(offset);\n      }\n    } catch (error) {\n      var errorStack = error.hasOwnProperty('stack') == 'undefined' ? error.stack.toString() : \"No Error Stack Available\";\n\n      this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));\n\n      return;\n    }\n\n    return messages;\n  };\n\n  ClientImpl.prototype._handleMessage = function (wireMessage) {\n    this._trace(\"Client._handleMessage\", wireMessage);\n\n    try {\n      switch (wireMessage.type) {\n        case MESSAGE_TYPE.CONNACK:\n          this._connectTimeout.cancel();\n\n          if (this._reconnectTimeout) this._reconnectTimeout.cancel(); // If we have started using clean session then clear up the local state.\n\n          if (this.connectOptions.cleanSession) {\n            for (var key in this._sentMessages) {\n              var sentMessage = this._sentMessages[key];\n              localStorage.removeItem(\"Sent:\" + this._localKey + sentMessage.messageIdentifier);\n            }\n\n            this._sentMessages = {};\n\n            for (var key in this._receivedMessages) {\n              var receivedMessage = this._receivedMessages[key];\n              localStorage.removeItem(\"Received:\" + this._localKey + receivedMessage.messageIdentifier);\n            }\n\n            this._receivedMessages = {};\n          } // Client connected and ready for business.\n\n\n          if (wireMessage.returnCode === 0) {\n            this.connected = true; // Jump to the end of the list of uris and stop looking for a good host.\n\n            if (this.connectOptions.uris) this.hostIndex = this.connectOptions.uris.length;\n          } else {\n            this._disconnected(ERROR.CONNACK_RETURNCODE.code, format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\n\n            break;\n          } // Resend messages.\n\n\n          var sequencedMessages = [];\n\n          for (var msgId in this._sentMessages) {\n            if (this._sentMessages.hasOwnProperty(msgId)) sequencedMessages.push(this._sentMessages[msgId]);\n          } // Also schedule qos 0 buffered messages if any\n\n\n          if (this._buffered_msg_queue.length > 0) {\n            var msg = null;\n\n            var fifo = this._buffered_msg_queue.reverse();\n\n            while (msg = fifo.pop()) {\n              sequencedMessages.push(msg);\n              if (this.onMessageDelivered) this._notify_msg_sent[msg] = this.onMessageDelivered(msg.payloadMessage);\n            }\n          } // Sort sentMessages into the original sent order.\n\n\n          var sequencedMessages = sequencedMessages.sort(function (a, b) {\n            return a.sequence - b.sequence;\n          });\n\n          for (var i = 0, len = sequencedMessages.length; i < len; i++) {\n            var sentMessage = sequencedMessages[i];\n\n            if (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {\n              var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {\n                messageIdentifier: sentMessage.messageIdentifier\n              });\n\n              this._schedule_message(pubRelMessage);\n            } else {\n              this._schedule_message(sentMessage);\n            }\n          } // Execute the connectOptions.onSuccess callback if there is one.\n          // Will also now return if this connection was the result of an automatic\n          // reconnect and which URI was successfully connected to.\n\n\n          if (this.connectOptions.onSuccess) {\n            this.connectOptions.onSuccess({\n              invocationContext: this.connectOptions.invocationContext\n            });\n          }\n\n          var reconnected = false;\n\n          if (this._reconnecting) {\n            reconnected = true;\n            this._reconnectInterval = 1;\n            this._reconnecting = false;\n          } // Execute the onConnected callback if there is one.\n\n\n          this._connected(reconnected, this._wsuri); // Process all queued messages now that the connection is established.\n\n\n          this._process_queue();\n\n          break;\n\n        case MESSAGE_TYPE.PUBLISH:\n          this._receivePublish(wireMessage);\n\n          break;\n\n        case MESSAGE_TYPE.PUBACK:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier]; // If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\n\n          if (sentMessage) {\n            delete this._sentMessages[wireMessage.messageIdentifier];\n            localStorage.removeItem(\"Sent:\" + this._localKey + wireMessage.messageIdentifier);\n            if (this.onMessageDelivered) this.onMessageDelivered(sentMessage.payloadMessage);\n          }\n\n          break;\n\n        case MESSAGE_TYPE.PUBREC:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier]; // If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\n\n          if (sentMessage) {\n            sentMessage.pubRecReceived = true;\n            var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {\n              messageIdentifier: wireMessage.messageIdentifier\n            });\n            this.store(\"Sent:\", sentMessage);\n\n            this._schedule_message(pubRelMessage);\n          }\n\n          break;\n\n        case MESSAGE_TYPE.PUBREL:\n          var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];\n          localStorage.removeItem(\"Received:\" + this._localKey + wireMessage.messageIdentifier); // If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\n\n          if (receivedMessage) {\n            this._receiveMessage(receivedMessage);\n\n            delete this._receivedMessages[wireMessage.messageIdentifier];\n          } // Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\n\n\n          var pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {\n            messageIdentifier: wireMessage.messageIdentifier\n          });\n\n          this._schedule_message(pubCompMessage);\n\n          break;\n\n        case MESSAGE_TYPE.PUBCOMP:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n          delete this._sentMessages[wireMessage.messageIdentifier];\n          localStorage.removeItem(\"Sent:\" + this._localKey + wireMessage.messageIdentifier);\n          if (this.onMessageDelivered) this.onMessageDelivered(sentMessage.payloadMessage);\n          break;\n\n        case MESSAGE_TYPE.SUBACK:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\n          if (sentMessage) {\n            if (sentMessage.timeOut) sentMessage.timeOut.cancel(); // This will need to be fixed when we add multiple topic support\n\n            if (wireMessage.returnCode[0] === 0x80) {\n              if (sentMessage.onFailure) {\n                sentMessage.onFailure(wireMessage.returnCode);\n              }\n            } else if (sentMessage.onSuccess) {\n              sentMessage.onSuccess(wireMessage.returnCode);\n            }\n\n            delete this._sentMessages[wireMessage.messageIdentifier];\n          }\n\n          break;\n\n        case MESSAGE_TYPE.UNSUBACK:\n          var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n\n          if (sentMessage) {\n            if (sentMessage.timeOut) sentMessage.timeOut.cancel();\n\n            if (sentMessage.callback) {\n              sentMessage.callback();\n            }\n\n            delete this._sentMessages[wireMessage.messageIdentifier];\n          }\n\n          break;\n\n        case MESSAGE_TYPE.PINGRESP:\n          /* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */\n          this.sendPinger.reset();\n          break;\n\n        case MESSAGE_TYPE.DISCONNECT:\n          // Clients do not expect to receive disconnect packets.\n          this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\n          break;\n\n        default:\n          this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\n      }\n    } catch (error) {\n      var errorStack = error.hasOwnProperty('stack') == 'undefined' ? error.stack.toString() : \"No Error Stack Available\";\n\n      this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));\n\n      return;\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._on_socket_error = function (error) {\n    if (!this._reconnecting) {\n      this._disconnected(ERROR.SOCKET_ERROR.code, format(ERROR.SOCKET_ERROR, [error.data]));\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._on_socket_close = function () {\n    if (!this._reconnecting) {\n      this._disconnected(ERROR.SOCKET_CLOSE.code, format(ERROR.SOCKET_CLOSE));\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._socket_send = function (wireMessage) {\n    if (wireMessage.type == 1) {\n      var wireMessageMasked = this._traceMask(wireMessage, \"password\");\n\n      this._trace(\"Client._socket_send\", wireMessageMasked);\n    } else this._trace(\"Client._socket_send\", wireMessage);\n\n    this.socket.send(wireMessage.encode());\n    /* We have proved to the server we are alive. */\n\n    this.sendPinger.reset();\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._receivePublish = function (wireMessage) {\n    switch (wireMessage.payloadMessage.qos) {\n      case \"undefined\":\n      case 0:\n        this._receiveMessage(wireMessage);\n\n        break;\n\n      case 1:\n        var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {\n          messageIdentifier: wireMessage.messageIdentifier\n        });\n\n        this._schedule_message(pubAckMessage);\n\n        this._receiveMessage(wireMessage);\n\n        break;\n\n      case 2:\n        this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n        this.store(\"Received:\", wireMessage);\n        var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {\n          messageIdentifier: wireMessage.messageIdentifier\n        });\n\n        this._schedule_message(pubRecMessage);\n\n        break;\n\n      default:\n        throw Error(\"Invaild qos=\" + wireMmessage.payloadMessage.qos);\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._receiveMessage = function (wireMessage) {\n    if (this.onMessageArrived) {\n      this.onMessageArrived(wireMessage.payloadMessage);\n    }\n  };\n  /**\r\n   * Client has connected.\r\n   * @param {reconnect} [boolean] indicate if this was a result of reconnect operation.\r\n   * @param {uri} [string] fully qualified WebSocket URI of the server.\r\n   */\n\n\n  ClientImpl.prototype._connected = function (reconnect, uri) {\n    // Execute the onConnected callback if there is one.\n    if (this.onConnected) this.onConnected(reconnect, uri);\n  };\n  /**\r\n   * Attempts to reconnect the client to the server.\r\n   * For each reconnect attempt, will double the reconnect interval\r\n   * up to 128 seconds.\r\n   */\n\n\n  ClientImpl.prototype._reconnect = function () {\n    this._trace(\"Client._reconnect\");\n\n    if (!this.connected) {\n      this._reconnecting = true;\n      this.sendPinger.cancel();\n      this.receivePinger.cancel();\n      if (this._reconnectInterval < 128) this._reconnectInterval = this._reconnectInterval * 2;\n\n      if (this.connectOptions.uris) {\n        this.hostIndex = 0;\n\n        this._doConnect(this.connectOptions.uris[0]);\n      } else {\n        this._doConnect(this.uri);\n      }\n    }\n  };\n  /**\r\n   * Client has disconnected either at its own request or because the server\r\n   * or network disconnected it. Remove all non-durable state.\r\n   * @param {errorCode} [number] the error number.\r\n   * @param {errorText} [string] the error text.\r\n   * @ignore\r\n   */\n\n\n  ClientImpl.prototype._disconnected = function (errorCode, errorText) {\n    this._trace(\"Client._disconnected\", errorCode, errorText);\n\n    if (errorCode !== undefined && this._reconnecting) {\n      //Continue automatic reconnect process\n      this._reconnectTimeout = new Timeout(this, window, this._reconnectInterval, this._reconnect);\n      return;\n    }\n\n    this.sendPinger.cancel();\n    this.receivePinger.cancel();\n\n    if (this._connectTimeout) {\n      this._connectTimeout.cancel();\n\n      this._connectTimeout = null;\n    } // Clear message buffers.\n\n\n    this._msg_queue = [];\n    this._buffered_msg_queue = [];\n    this._notify_msg_sent = {};\n\n    if (this.socket) {\n      // Cancel all socket callbacks so that they cannot be driven again by this socket.\n      this.socket.onopen = null;\n      this.socket.onmessage = null;\n      this.socket.onerror = null;\n      this.socket.onclose = null;\n      if (this.socket.readyState === 1) this.socket.close();\n      delete this.socket;\n    }\n\n    if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) {\n      // Try the next host.\n      this.hostIndex++;\n\n      this._doConnect(this.connectOptions.uris[this.hostIndex]);\n    } else {\n      if (errorCode === undefined) {\n        errorCode = ERROR.OK.code;\n        errorText = format(ERROR.OK);\n      } // Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\n\n\n      if (this.connected) {\n        this.connected = false; // Execute the connectionLostCallback if there is one, and we were connected.\n\n        if (this.onConnectionLost) {\n          this.onConnectionLost({\n            errorCode: errorCode,\n            errorMessage: errorText,\n            reconnect: this.connectOptions.reconnect,\n            uri: this._wsuri\n          });\n        }\n\n        if (errorCode !== ERROR.OK.code && this.connectOptions.reconnect) {\n          // Start automatic reconnect process for the very first time since last successful connect.\n          this._reconnectInterval = 1;\n\n          this._reconnect();\n\n          return;\n        }\n      } else {\n        // Otherwise we never had a connection, so indicate that the connect has failed.\n        if (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {\n          this._trace(\"Failed to connect V4, dropping back to V3\");\n\n          this.connectOptions.mqttVersion = 3;\n\n          if (this.connectOptions.uris) {\n            this.hostIndex = 0;\n\n            this._doConnect(this.connectOptions.uris[0]);\n          } else {\n            this._doConnect(this.uri);\n          }\n        } else if (this.connectOptions.onFailure) {\n          this.connectOptions.onFailure({\n            invocationContext: this.connectOptions.invocationContext,\n            errorCode: errorCode,\n            errorMessage: errorText\n          });\n        }\n      }\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._trace = function () {\n    // Pass trace message back to client's callback function\n    if (this.traceFunction) {\n      for (var i in arguments) {\n        if (typeof arguments[i] !== \"undefined\") arguments.splice(i, 1, JSON.stringify(arguments[i]));\n      }\n\n      var record = Array.prototype.slice.call(arguments).join(\"\");\n      this.traceFunction({\n        severity: \"Debug\",\n        message: record\n      });\n    } //buffer style trace\n\n\n    if (this._traceBuffer !== null) {\n      for (var i = 0, max = arguments.length; i < max; i++) {\n        if (this._traceBuffer.length == this._MAX_TRACE_ENTRIES) {\n          this._traceBuffer.shift();\n        }\n\n        if (i === 0) this._traceBuffer.push(arguments[i]);else if (typeof arguments[i] === \"undefined\") this._traceBuffer.push(arguments[i]);else this._traceBuffer.push(\"  \" + JSON.stringify(arguments[i]));\n      }\n    }\n  };\n  /** @ignore */\n\n\n  ClientImpl.prototype._traceMask = function (traceObject, masked) {\n    var traceObjectMasked = {};\n\n    for (var attr in traceObject) {\n      if (traceObject.hasOwnProperty(attr)) {\n        if (attr == masked) traceObjectMasked[attr] = \"******\";else traceObjectMasked[attr] = traceObject[attr];\n      }\n    }\n\n    return traceObjectMasked;\n  }; // ------------------------------------------------------------------------\n  // Public Programming interface.\n  // ------------------------------------------------------------------------\n\n  /**\r\n   * The JavaScript application communicates to the server using a {@link Paho.MQTT.Client} object.\r\n   * <p>\r\n   * Most applications will create just one Client object and then call its connect() method,\r\n   * however applications can create more than one Client object if they wish.\r\n   * In this case the combination of host, port and clientId attributes must be different for each Client object.\r\n   * <p>\r\n   * The send, subscribe and unsubscribe methods are implemented as asynchronous JavaScript methods\r\n   * (even though the underlying protocol exchange might be synchronous in nature).\r\n   * This means they signal their completion by calling back to the application,\r\n   * via Success or Failure callback functions provided by the application on the method in question.\r\n   * Such callbacks are called at most once per method invocation and do not persist beyond the lifetime\r\n   * of the script that made the invocation.\r\n   * <p>\r\n   * In contrast there are some callback functions, most notably <i>onMessageArrived</i>,\r\n   * that are defined on the {@link Paho.MQTT.Client} object.\r\n   * These may get called multiple times, and aren't directly related to specific method invocations made by the client.\r\n   *\r\n   * @name Paho.MQTT.Client\r\n   *\r\n   * @constructor\r\n   *\r\n   * @param {string} host - the address of the messaging server, as a fully qualified WebSocket URI, as a DNS name or dotted decimal IP address.\r\n   * @param {number} port - the port number to connect to - only required if host is not a URI\r\n   * @param {string} path - the path on the host to connect to - only used if host is not a URI. Default: '/mqtt'.\r\n   * @param {string} clientId - the Messaging client identifier, between 1 and 23 characters in length.\r\n   *\r\n   * @property {string} host - <i>read only</i> the server's DNS hostname or dotted decimal IP address.\r\n   * @property {number} port - <i>read only</i> the server's port.\r\n   * @property {string} path - <i>read only</i> the server's path.\r\n   * @property {string} clientId - <i>read only</i> used when connecting to the server.\r\n   * @property {function} onConnectionLost - called when a connection has been lost.\r\n   *                            after a connect() method has succeeded.\r\n   *                            Establish the call back used when a connection has been lost. The connection may be\r\n   *                            lost because the client initiates a disconnect or because the server or network\r\n   *                            cause the client to be disconnected. The disconnect call back may be called without\r\n   *                            the connectionComplete call back being invoked if, for example the client fails to\r\n   *                            connect.\r\n   *                            A single response object parameter is passed to the onConnectionLost callback containing the following fields:\r\n   *                            <ol>\r\n   *                            <li>errorCode\r\n   *                            <li>errorMessage\r\n   *                            </ol>\r\n   * @property {function} onMessageDelivered - called when a message has been delivered.\r\n   *                            All processing that this Client will ever do has been completed. So, for example,\r\n   *                            in the case of a Qos=2 message sent by this client, the PubComp flow has been received from the server\r\n   *                            and the message has been removed from persistent storage before this callback is invoked.\r\n   *                            Parameters passed to the onMessageDelivered callback are:\r\n   *                            <ol>\r\n   *                            <li>{@link Paho.MQTT.Message} that was delivered.\r\n   *                            </ol>\r\n   * @property {function} onMessageArrived - called when a message has arrived in this Paho.MQTT.client.\r\n   *                            Parameters passed to the onMessageArrived callback are:\r\n   *                            <ol>\r\n   *                            <li>{@link Paho.MQTT.Message} that has arrived.\r\n   *                            </ol>\r\n   * @property {function} onConnected - called when a connection is successfully made to the server.\r\n   *                                  after a connect() method.\r\n   *                                  Parameters passed to the onConnected callback are:\r\n   *                                  <ol>\r\n   *                                  <li>reconnect (boolean) - If true, the connection was the result of a reconnect.</li>\r\n   *                                  <li>URI (string) - The URI used to connect to the server.</li>\r\n   *                                  </ol>\r\n   * @property {boolean} disconnectedPublishing - if set, will enable disconnected publishing in\r\n   *                                            in the event that the connection to the server is lost.\r\n   * @property {number} disconnectedBufferSize - Used to set the maximum number of messages that the disconnected\r\n   *                                             buffer will hold before rejecting new messages. Default size: 5000 messages\r\n   * @property {function} trace - called whenever trace is called. TODO\r\n   */\n\n\n  var Client = function Client(host, port, path, clientId) {\n    var uri;\n    if (typeof host !== \"string\") throw new Error(format(ERROR.INVALID_TYPE, [_typeof(host), \"host\"]));\n\n    if (arguments.length == 2) {\n      // host: must be full ws:// uri\n      // port: clientId\n      clientId = port;\n      uri = host;\n      var match = uri.match(/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/);\n\n      if (match) {\n        host = match[4] || match[2];\n        port = parseInt(match[7]);\n        path = match[8];\n      } else {\n        throw new Error(format(ERROR.INVALID_ARGUMENT, [host, \"host\"]));\n      }\n    } else {\n      if (arguments.length == 3) {\n        clientId = path;\n        path = \"/mqtt\";\n      }\n\n      if (typeof port !== \"number\" || port < 0) throw new Error(format(ERROR.INVALID_TYPE, [_typeof(port), \"port\"]));\n      if (typeof path !== \"string\") throw new Error(format(ERROR.INVALID_TYPE, [_typeof(path), \"path\"]));\n      var ipv6AddSBracket = host.indexOf(\":\") !== -1 && host.slice(0, 1) !== \"[\" && host.slice(-1) !== \"]\";\n      uri = \"ws://\" + (ipv6AddSBracket ? \"[\" + host + \"]\" : host) + \":\" + port + path;\n    }\n\n    var clientIdLength = 0;\n\n    for (var i = 0; i < clientId.length; i++) {\n      var charCode = clientId.charCodeAt(i);\n\n      if (0xD800 <= charCode && charCode <= 0xDBFF) {\n        i++; // Surrogate pair.\n      }\n\n      clientIdLength++;\n    }\n\n    if (typeof clientId !== \"string\" || clientIdLength > 65535) throw new Error(format(ERROR.INVALID_ARGUMENT, [clientId, \"clientId\"]));\n    var client = new ClientImpl(uri, host, port, path, clientId);\n\n    this._getHost = function () {\n      return host;\n    };\n\n    this._setHost = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getPort = function () {\n      return port;\n    };\n\n    this._setPort = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getPath = function () {\n      return path;\n    };\n\n    this._setPath = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getURI = function () {\n      return uri;\n    };\n\n    this._setURI = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getClientId = function () {\n      return client.clientId;\n    };\n\n    this._setClientId = function () {\n      throw new Error(format(ERROR.UNSUPPORTED_OPERATION));\n    };\n\n    this._getOnConnected = function () {\n      return client.onConnected;\n    };\n\n    this._setOnConnected = function (newOnConnected) {\n      if (typeof newOnConnected === \"function\") client.onConnected = newOnConnected;else throw new Error(format(ERROR.INVALID_TYPE, [_typeof(newOnConnected), \"onConnected\"]));\n    };\n\n    this._getDisconnectedPublishing = function () {\n      return client.disconnectedPublishing;\n    };\n\n    this._setDisconnectedPublishing = function (newDisconnectedPublishing) {\n      client.disconnectedPublishing = newDisconnectedPublishing;\n    };\n\n    this._getDisconnectedBufferSize = function () {\n      return client.disconnectedBufferSize;\n    };\n\n    this._setDisconnectedBufferSize = function (newDisconnectedBufferSize) {\n      client.disconnectedBufferSize = newDisconnectedBufferSize;\n    };\n\n    this._getOnConnectionLost = function () {\n      return client.onConnectionLost;\n    };\n\n    this._setOnConnectionLost = function (newOnConnectionLost) {\n      if (typeof newOnConnectionLost === \"function\") client.onConnectionLost = newOnConnectionLost;else throw new Error(format(ERROR.INVALID_TYPE, [_typeof(newOnConnectionLost), \"onConnectionLost\"]));\n    };\n\n    this._getOnMessageDelivered = function () {\n      return client.onMessageDelivered;\n    };\n\n    this._setOnMessageDelivered = function (newOnMessageDelivered) {\n      if (typeof newOnMessageDelivered === \"function\") client.onMessageDelivered = newOnMessageDelivered;else throw new Error(format(ERROR.INVALID_TYPE, [_typeof(newOnMessageDelivered), \"onMessageDelivered\"]));\n    };\n\n    this._getOnMessageArrived = function () {\n      return client.onMessageArrived;\n    };\n\n    this._setOnMessageArrived = function (newOnMessageArrived) {\n      if (typeof newOnMessageArrived === \"function\") client.onMessageArrived = newOnMessageArrived;else throw new Error(format(ERROR.INVALID_TYPE, [_typeof(newOnMessageArrived), \"onMessageArrived\"]));\n    };\n\n    this._getTrace = function () {\n      return client.traceFunction;\n    };\n\n    this._setTrace = function (trace) {\n      if (typeof trace === \"function\") {\n        client.traceFunction = trace;\n      } else {\n        throw new Error(format(ERROR.INVALID_TYPE, [_typeof(trace), \"onTrace\"]));\n      }\n    };\n    /**\r\n     * Connect this Messaging client to its server.\r\n     *\r\n     * @name Paho.MQTT.Client#connect\r\n     * @function\r\n     * @param {object} connectOptions - Attributes used with the connection.\r\n     * @param {number} connectOptions.timeout - If the connect has not succeeded within this\r\n     *                    number of seconds, it is deemed to have failed.\r\n     *                    The default is 30 seconds.\r\n     * @param {string} connectOptions.userName - Authentication username for this connection.\r\n     * @param {string} connectOptions.password - Authentication password for this connection.\r\n     * @param {Paho.MQTT.Message} connectOptions.willMessage - sent by the server when the client\r\n     *                    disconnects abnormally.\r\n     * @param {number} connectOptions.keepAliveInterval - the server disconnects this client if\r\n     *                    there is no activity for this number of seconds.\r\n     *                    The default value of 60 seconds is assumed if not set.\r\n     * @param {boolean} connectOptions.cleanSession - if true(default) the client and server\r\n     *                    persistent state is deleted on successful connect.\r\n     * @param {boolean} connectOptions.useSSL - if present and true, use an SSL Websocket connection.\r\n     * @param {object} connectOptions.invocationContext - passed to the onSuccess callback or onFailure callback.\r\n     * @param {function} connectOptions.onSuccess - called when the connect acknowledgement\r\n     *                    has been received from the server.\r\n     * A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n     * <ol>\r\n     * <li>invocationContext as passed in to the onSuccess method in the connectOptions.\r\n     * </ol>\r\n     * @param {function} connectOptions.onFailure - called when the connect request has failed or timed out.\r\n     * A single response object parameter is passed to the onFailure callback containing the following fields:\r\n     * <ol>\r\n     * <li>invocationContext as passed in to the onFailure method in the connectOptions.\r\n     * <li>errorCode a number indicating the nature of the error.\r\n     * <li>errorMessage text describing the error.\r\n     * </ol>\r\n     * @param {array} connectOptions.hosts - If present this contains either a set of hostnames or fully qualified\r\n     * WebSocket URIs (ws://iot.eclipse.org:80/ws), that are tried in order in place\r\n     * of the host and port paramater on the construtor. The hosts are tried one at at time in order until\r\n     * one of then succeeds.\r\n     * @param {array} connectOptions.ports - If present the set of ports matching the hosts. If hosts contains URIs, this property\r\n     * is not used.\r\n     * @param {boolean} connectOptions.reconnect - Sets whether the client will automatically attempt to reconnect\r\n     * to the server if the connection is lost.\r\n     *<ul>\r\n     *<li>If set to false, the client will not attempt to automatically reconnect to the server in the event that the\r\n     * connection is lost.</li>\r\n     *<li>If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server.\r\n     * It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay\r\n     * will double until it is at 2 minutes at which point the delay will stay at 2 minutes.</li>\r\n     *</ul>\r\n     * @param {number} connectOptions.mqttVersion - The version of MQTT to use to connect to the MQTT Broker.\r\n     *<ul>\r\n     *<li>3 - MQTT V3.1</li>\r\n     *<li>4 - MQTT V3.1.1</li>\r\n     *</ul>\r\n     * @param {boolean} connectOptions.mqttVersionExplicit - If set to true, will force the connection to use the\r\n     * selected MQTT Version or will fail to connect.\r\n     * @param {array} connectOptions.uris - If present, should contain a list of fully qualified WebSocket uris\r\n     * (e.g. ws://iot.eclipse.org:80/ws), that are tried in order in place of the host and port parameter of the construtor.\r\n     * The uris are tried one at a time in order until one of them succeeds. Do not use this in conjunction with hosts as\r\n     * the hosts array will be converted to uris and will overwrite this property.\r\n     * @throws {InvalidState} If the client is not in disconnected state. The client must have received connectionLost\r\n     * or disconnected before calling connect for a second or subsequent time.\r\n     */\n\n\n    this.connect = function (connectOptions) {\n      connectOptions = connectOptions || {};\n      validate(connectOptions, {\n        timeout: \"number\",\n        userName: \"string\",\n        password: \"string\",\n        willMessage: \"object\",\n        keepAliveInterval: \"number\",\n        cleanSession: \"boolean\",\n        useSSL: \"boolean\",\n        invocationContext: \"object\",\n        onSuccess: \"function\",\n        onFailure: \"function\",\n        hosts: \"object\",\n        ports: \"object\",\n        reconnect: \"boolean\",\n        mqttVersion: \"number\",\n        mqttVersionExplicit: \"boolean\",\n        uris: \"object\"\n      }); // If no keep alive interval is set, assume 60 seconds.\n\n      if (connectOptions.keepAliveInterval === undefined) connectOptions.keepAliveInterval = 60;\n\n      if (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {\n        throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, \"connectOptions.mqttVersion\"]));\n      }\n\n      if (connectOptions.mqttVersion === undefined) {\n        connectOptions.mqttVersionExplicit = false;\n        connectOptions.mqttVersion = 4;\n      } else {\n        connectOptions.mqttVersionExplicit = true;\n      } //Check that if password is set, so is username\n\n\n      if (connectOptions.password !== undefined && connectOptions.userName === undefined) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, \"connectOptions.password\"]));\n\n      if (connectOptions.willMessage) {\n        if (!(connectOptions.willMessage instanceof Message)) throw new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, \"connectOptions.willMessage\"])); // The will message must have a payload that can be represented as a string.\n        // Cause the willMessage to throw an exception if this is not the case.\n\n        connectOptions.willMessage.stringPayload = null;\n        if (typeof connectOptions.willMessage.destinationName === \"undefined\") throw new Error(format(ERROR.INVALID_TYPE, [_typeof(connectOptions.willMessage.destinationName), \"connectOptions.willMessage.destinationName\"]));\n      }\n\n      if (typeof connectOptions.cleanSession === \"undefined\") connectOptions.cleanSession = true;\n\n      if (connectOptions.hosts) {\n        if (!(connectOptions.hosts instanceof Array)) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n        if (connectOptions.hosts.length < 1) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n        var usingURIs = false;\n\n        for (var i = 0; i < connectOptions.hosts.length; i++) {\n          if (typeof connectOptions.hosts[i] !== \"string\") throw new Error(format(ERROR.INVALID_TYPE, [_typeof(connectOptions.hosts[i]), \"connectOptions.hosts[\" + i + \"]\"]));\n\n          if (/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(connectOptions.hosts[i])) {\n            if (i === 0) {\n              usingURIs = true;\n            } else if (!usingURIs) {\n              throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\n            }\n          } else if (usingURIs) {\n            throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\n          }\n        }\n\n        if (!usingURIs) {\n          if (!connectOptions.ports) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n          if (!(connectOptions.ports instanceof Array)) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n          if (connectOptions.hosts.length !== connectOptions.ports.length) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n          connectOptions.uris = [];\n\n          for (var i = 0; i < connectOptions.hosts.length; i++) {\n            if (typeof connectOptions.ports[i] !== \"number\" || connectOptions.ports[i] < 0) throw new Error(format(ERROR.INVALID_TYPE, [_typeof(connectOptions.ports[i]), \"connectOptions.ports[\" + i + \"]\"]));\n            var host = connectOptions.hosts[i];\n            var port = connectOptions.ports[i];\n            var ipv6 = host.indexOf(\":\") !== -1;\n            uri = \"ws://\" + (ipv6 ? \"[\" + host + \"]\" : host) + \":\" + port + path;\n            connectOptions.uris.push(uri);\n          }\n        } else {\n          connectOptions.uris = connectOptions.hosts;\n        }\n      }\n\n      client.connect(connectOptions);\n    };\n    /**\r\n     * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\r\n     *\r\n     * @name Paho.MQTT.Client#subscribe\r\n     * @function\r\n     * @param {string} filter describing the destinations to receive messages from.\r\n     * <br>\r\n     * @param {object} subscribeOptions - used to control the subscription\r\n     *\r\n     * @param {number} subscribeOptions.qos - the maiximum qos of any publications sent\r\n     *                                  as a result of making this subscription.\r\n     * @param {object} subscribeOptions.invocationContext - passed to the onSuccess callback\r\n     *                                  or onFailure callback.\r\n     * @param {function} subscribeOptions.onSuccess - called when the subscribe acknowledgement\r\n     *                                  has been received from the server.\r\n     *                                  A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n     *                                  <ol>\r\n     *                                  <li>invocationContext if set in the subscribeOptions.\r\n     *                                  </ol>\r\n     * @param {function} subscribeOptions.onFailure - called when the subscribe request has failed or timed out.\r\n     *                                  A single response object parameter is passed to the onFailure callback containing the following fields:\r\n     *                                  <ol>\r\n     *                                  <li>invocationContext - if set in the subscribeOptions.\r\n     *                                  <li>errorCode - a number indicating the nature of the error.\r\n     *                                  <li>errorMessage - text describing the error.\r\n     *                                  </ol>\r\n     * @param {number} subscribeOptions.timeout - which, if present, determines the number of\r\n     *                                  seconds after which the onFailure calback is called.\r\n     *                                  The presence of a timeout does not prevent the onSuccess\r\n     *                                  callback from being called when the subscribe completes.\r\n     * @throws {InvalidState} if the client is not in connected state.\r\n     */\n\n\n    this.subscribe = function (filter, subscribeOptions) {\n      if (typeof filter !== \"string\") throw new Error(\"Invalid argument:\" + filter);\n      subscribeOptions = subscribeOptions || {};\n      validate(subscribeOptions, {\n        qos: \"number\",\n        invocationContext: \"object\",\n        onSuccess: \"function\",\n        onFailure: \"function\",\n        timeout: \"number\"\n      });\n      if (subscribeOptions.timeout && !subscribeOptions.onFailure) throw new Error(\"subscribeOptions.timeout specified with no onFailure callback.\");\n      if (typeof subscribeOptions.qos !== \"undefined\" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2)) throw new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, \"subscribeOptions.qos\"]));\n      client.subscribe(filter, subscribeOptions);\n    };\n    /**\r\n     * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\r\n     *\r\n     * @name Paho.MQTT.Client#unsubscribe\r\n     * @function\r\n     * @param {string} filter - describing the destinations to receive messages from.\r\n     * @param {object} unsubscribeOptions - used to control the subscription\r\n     * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback\r\n                                          or onFailure callback.\r\n     * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.\r\n     *                                    A single response object parameter is passed to the\r\n     *                                    onSuccess callback containing the following fields:\r\n     *                                    <ol>\r\n     *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n     *                                    </ol>\r\n     * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.\r\n     *                                    A single response object parameter is passed to the onFailure callback containing the following fields:\r\n     *                                    <ol>\r\n     *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n     *                                    <li>errorCode - a number indicating the nature of the error.\r\n     *                                    <li>errorMessage - text describing the error.\r\n     *                                    </ol>\r\n     * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds\r\n     *                                    after which the onFailure callback is called. The presence of\r\n     *                                    a timeout does not prevent the onSuccess callback from being\r\n     *                                    called when the unsubscribe completes\r\n     * @throws {InvalidState} if the client is not in connected state.\r\n     */\n\n\n    this.unsubscribe = function (filter, unsubscribeOptions) {\n      if (typeof filter !== \"string\") throw new Error(\"Invalid argument:\" + filter);\n      unsubscribeOptions = unsubscribeOptions || {};\n      validate(unsubscribeOptions, {\n        invocationContext: \"object\",\n        onSuccess: \"function\",\n        onFailure: \"function\",\n        timeout: \"number\"\n      });\n      if (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure) throw new Error(\"unsubscribeOptions.timeout specified with no onFailure callback.\");\n      client.unsubscribe(filter, unsubscribeOptions);\n    };\n    /**\r\n     * Send a message to the consumers of the destination in the Message.\r\n     *\r\n     * @name Paho.MQTT.Client#send\r\n     * @function\r\n     * @param {string|Paho.MQTT.Message} topic - <b>mandatory</b> The name of the destination to which the message is to be sent.\r\n     *                     - If it is the only parameter, used as Paho.MQTT.Message object.\r\n     * @param {String|ArrayBuffer} payload - The message data to be sent.\r\n     * @param {number} qos The Quality of Service used to deliver the message.\r\n     *      <dl>\r\n     *          <dt>0 Best effort (default).\r\n     *              <dt>1 At least once.\r\n     *              <dt>2 Exactly once.\r\n     *      </dl>\r\n     * @param {Boolean} retained If true, the message is to be retained by the server and delivered\r\n     *                     to both current and future subscriptions.\r\n     *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n     *                     A received message has the retained boolean set to true if the message was published\r\n     *                     with the retained boolean set to true\r\n     *                     and the subscrption was made after the message has been published.\r\n     * @throws {InvalidState} if the client is not connected.\r\n     */\n\n\n    this.send = function (topic, payload, qos, retained) {\n      var message;\n\n      if (arguments.length === 0) {\n        throw new Error(\"Invalid argument.\" + \"length\");\n      } else if (arguments.length == 1) {\n        if (!(topic instanceof Message) && typeof topic !== \"string\") throw new Error(\"Invalid argument:\" + _typeof(topic));\n        message = topic;\n        if (typeof message.destinationName === \"undefined\") throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, \"Message.destinationName\"]));\n        client.send(message);\n      } else {\n        //parameter checking in Message object\n        message = new Message(payload);\n        message.destinationName = topic;\n        if (arguments.length >= 3) message.qos = qos;\n        if (arguments.length >= 4) message.retained = retained;\n        client.send(message);\n      }\n    };\n    /**\r\n     * Publish a message to the consumers of the destination in the Message.\r\n     * Synonym for Paho.Mqtt.Client#send\r\n     *\r\n     * @name Paho.MQTT.Client#publish\r\n     * @function\r\n     * @param {string|Paho.MQTT.Message} topic - <b>mandatory</b> The name of the topic to which the message is to be published.\r\n     *                     - If it is the only parameter, used as Paho.MQTT.Message object.\r\n     * @param {String|ArrayBuffer} payload - The message data to be published.\r\n     * @param {number} qos The Quality of Service used to deliver the message.\r\n     *      <dl>\r\n     *          <dt>0 Best effort (default).\r\n     *              <dt>1 At least once.\r\n     *              <dt>2 Exactly once.\r\n     *      </dl>\r\n     * @param {Boolean} retained If true, the message is to be retained by the server and delivered\r\n     *                     to both current and future subscriptions.\r\n     *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n     *                     A received message has the retained boolean set to true if the message was published\r\n     *                     with the retained boolean set to true\r\n     *                     and the subscrption was made after the message has been published.\r\n     * @throws {InvalidState} if the client is not connected.\r\n     */\n\n\n    this.publish = function (topic, payload, qos, retained) {\n      console.log(\"Publising message to: \", topic);\n      var message;\n\n      if (arguments.length === 0) {\n        throw new Error(\"Invalid argument.\" + \"length\");\n      } else if (arguments.length == 1) {\n        if (!(topic instanceof Message) && typeof topic !== \"string\") throw new Error(\"Invalid argument:\" + _typeof(topic));\n        message = topic;\n        if (typeof message.destinationName === \"undefined\") throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, \"Message.destinationName\"]));\n        client.send(message);\n      } else {\n        //parameter checking in Message object\n        message = new Message(payload);\n        message.destinationName = topic;\n        if (arguments.length >= 3) message.qos = qos;\n        if (arguments.length >= 4) message.retained = retained;\n        client.send(message);\n      }\n    };\n    /**\r\n     * Normal disconnect of this Messaging client from its server.\r\n     *\r\n     * @name Paho.MQTT.Client#disconnect\r\n     * @function\r\n     * @throws {InvalidState} if the client is already disconnected.\r\n     */\n\n\n    this.disconnect = function () {\n      client.disconnect();\n    };\n    /**\r\n     * Get the contents of the trace log.\r\n     *\r\n     * @name Paho.MQTT.Client#getTraceLog\r\n     * @function\r\n     * @return {Object[]} tracebuffer containing the time ordered trace records.\r\n     */\n\n\n    this.getTraceLog = function () {\n      return client.getTraceLog();\n    };\n    /**\r\n     * Start tracing.\r\n     *\r\n     * @name Paho.MQTT.Client#startTrace\r\n     * @function\r\n     */\n\n\n    this.startTrace = function () {\n      client.startTrace();\n    };\n    /**\r\n     * Stop tracing.\r\n     *\r\n     * @name Paho.MQTT.Client#stopTrace\r\n     * @function\r\n     */\n\n\n    this.stopTrace = function () {\n      client.stopTrace();\n    };\n\n    this.isConnected = function () {\n      return client.connected;\n    };\n  };\n\n  Client.prototype = {\n    get host() {\n      return this._getHost();\n    },\n\n    set host(newHost) {\n      this._setHost(newHost);\n    },\n\n    get port() {\n      return this._getPort();\n    },\n\n    set port(newPort) {\n      this._setPort(newPort);\n    },\n\n    get path() {\n      return this._getPath();\n    },\n\n    set path(newPath) {\n      this._setPath(newPath);\n    },\n\n    get clientId() {\n      return this._getClientId();\n    },\n\n    set clientId(newClientId) {\n      this._setClientId(newClientId);\n    },\n\n    get onConnected() {\n      return this._getOnConnected();\n    },\n\n    set onConnected(newOnConnected) {\n      this._setOnConnected(newOnConnected);\n    },\n\n    get disconnectedPublishing() {\n      return this._getDisconnectedPublishing();\n    },\n\n    set disconnectedPublishing(newDisconnectedPublishing) {\n      this._setDisconnectedPublishing(newDisconnectedPublishing);\n    },\n\n    get disconnectedBufferSize() {\n      return this._getDisconnectedBufferSize();\n    },\n\n    set disconnectedBufferSize(newDisconnectedBufferSize) {\n      this._setDisconnectedBufferSize(newDisconnectedBufferSize);\n    },\n\n    get onConnectionLost() {\n      return this._getOnConnectionLost();\n    },\n\n    set onConnectionLost(newOnConnectionLost) {\n      this._setOnConnectionLost(newOnConnectionLost);\n    },\n\n    get onMessageDelivered() {\n      return this._getOnMessageDelivered();\n    },\n\n    set onMessageDelivered(newOnMessageDelivered) {\n      this._setOnMessageDelivered(newOnMessageDelivered);\n    },\n\n    get onMessageArrived() {\n      return this._getOnMessageArrived();\n    },\n\n    set onMessageArrived(newOnMessageArrived) {\n      this._setOnMessageArrived(newOnMessageArrived);\n    },\n\n    get trace() {\n      return this._getTrace();\n    },\n\n    set trace(newTraceFunction) {\n      this._setTrace(newTraceFunction);\n    }\n\n  };\n  /**\r\n   * An application message, sent or received.\r\n   * <p>\r\n   * All attributes may be null, which implies the default values.\r\n   *\r\n   * @name Paho.MQTT.Message\r\n   * @constructor\r\n   * @param {String|ArrayBuffer} payload The message data to be sent.\r\n   * <p>\r\n   * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\r\n   * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\r\n   * <p>\r\n   * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\r\n   *                    (for messages about to be sent) or the name of the destination from which the message has been received.\r\n   *                    (for messages received by the onMessage function).\r\n   * <p>\r\n   * @property {number} qos The Quality of Service used to deliver the message.\r\n   * <dl>\r\n   *     <dt>0 Best effort (default).\r\n   *     <dt>1 At least once.\r\n   *     <dt>2 Exactly once.\r\n   * </dl>\r\n   * <p>\r\n   * @property {Boolean} retained If true, the message is to be retained by the server and delivered\r\n   *                     to both current and future subscriptions.\r\n   *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n   *                     A received message has the retained boolean set to true if the message was published\r\n   *                     with the retained boolean set to true\r\n   *                     and the subscrption was made after the message has been published.\r\n   * <p>\r\n   * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received.\r\n   *                     This is only set on messages received from the server.\r\n   *\r\n   */\n\n  var Message = function Message(newPayload) {\n    var payload;\n\n    if (typeof newPayload === \"string\" || newPayload instanceof ArrayBuffer || newPayload instanceof Int8Array || newPayload instanceof Uint8Array || newPayload instanceof Int16Array || newPayload instanceof Uint16Array || newPayload instanceof Int32Array || newPayload instanceof Uint32Array || newPayload instanceof Float32Array || newPayload instanceof Float64Array) {\n      payload = newPayload;\n    } else {\n      throw format(ERROR.INVALID_ARGUMENT, [newPayload, \"newPayload\"]);\n    }\n\n    this._getPayloadString = function () {\n      if (typeof payload === \"string\") return payload;else return parseUTF8(payload, 0, payload.length);\n    };\n\n    this._getPayloadBytes = function () {\n      if (typeof payload === \"string\") {\n        var buffer = new ArrayBuffer(UTF8Length(payload));\n        var byteStream = new Uint8Array(buffer);\n        stringToUTF8(payload, byteStream, 0);\n        return byteStream;\n      } else {\n        return payload;\n      }\n    };\n\n    var destinationName;\n\n    this._getDestinationName = function () {\n      return destinationName;\n    };\n\n    this._setDestinationName = function (newDestinationName) {\n      if (typeof newDestinationName === \"string\") destinationName = newDestinationName;else throw new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, \"newDestinationName\"]));\n    };\n\n    var qos = 0;\n\n    this._getQos = function () {\n      return qos;\n    };\n\n    this._setQos = function (newQos) {\n      if (newQos === 0 || newQos === 1 || newQos === 2) qos = newQos;else throw new Error(\"Invalid argument:\" + newQos);\n    };\n\n    var retained = false;\n\n    this._getRetained = function () {\n      return retained;\n    };\n\n    this._setRetained = function (newRetained) {\n      if (typeof newRetained === \"boolean\") retained = newRetained;else throw new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, \"newRetained\"]));\n    };\n\n    var duplicate = false;\n\n    this._getDuplicate = function () {\n      return duplicate;\n    };\n\n    this._setDuplicate = function (newDuplicate) {\n      duplicate = newDuplicate;\n    };\n  };\n\n  Message.prototype = {\n    get payloadString() {\n      return this._getPayloadString();\n    },\n\n    get payloadBytes() {\n      return this._getPayloadBytes();\n    },\n\n    get destinationName() {\n      return this._getDestinationName();\n    },\n\n    set destinationName(newDestinationName) {\n      this._setDestinationName(newDestinationName);\n    },\n\n    get topic() {\n      return this._getDestinationName();\n    },\n\n    set topic(newTopic) {\n      this._setDestinationName(newTopic);\n    },\n\n    get qos() {\n      return this._getQos();\n    },\n\n    set qos(newQos) {\n      this._setQos(newQos);\n    },\n\n    get retained() {\n      return this._getRetained();\n    },\n\n    set retained(newRetained) {\n      this._setRetained(newRetained);\n    },\n\n    get duplicate() {\n      return this._getDuplicate();\n    },\n\n    set duplicate(newDuplicate) {\n      this._setDuplicate(newDuplicate);\n    }\n\n  }; // Module contents.\n\n  return {\n    Client: Client,\n    Message: Message\n  };\n}(window);\n\nexport default Paho; // return PahoMQTT;\n// });",{"version":3,"sources":["C:\\Users\\Sovannarith Phan\\Utility_Website\\web\\src\\service\\paho-mqtt.js"],"names":["Paho","MQTT","global","version","buildLevel","MESSAGE_TYPE","CONNECT","CONNACK","PUBLISH","PUBACK","PUBREC","PUBREL","PUBCOMP","SUBSCRIBE","SUBACK","UNSUBSCRIBE","UNSUBACK","PINGREQ","PINGRESP","DISCONNECT","validate","obj","keys","key","hasOwnProperty","Error","format","ERROR","INVALID_TYPE","errorStr","validKey","scope","f","apply","arguments","OK","code","text","CONNECT_TIMEOUT","SUBSCRIBE_TIMEOUT","UNSUBSCRIBE_TIMEOUT","PING_TIMEOUT","INTERNAL_ERROR","CONNACK_RETURNCODE","SOCKET_ERROR","SOCKET_CLOSE","MALFORMED_UTF","UNSUPPORTED","INVALID_STATE","INVALID_ARGUMENT","UNSUPPORTED_OPERATION","INVALID_STORED_DATA","INVALID_MQTT_MESSAGE_TYPE","MALFORMED_UNICODE","BUFFER_FULL","CONNACK_RC","error","substitutions","field","start","i","length","indexOf","part1","substring","part2","MqttProtoIdentifierv3","MqttProtoIdentifierv4","WireMessage","type","options","name","prototype","encode","first","remLength","topicStrLength","destinationNameLength","willMessagePayloadBytes","messageIdentifier","undefined","mqttVersion","UTF8Length","clientId","willMessage","destinationName","payloadBytes","Uint8Array","byteLength","userName","password","topics","requestedQos","payloadMessage","duplicate","qos","retained","ArrayBuffer","buffer","mbi","encodeMBI","pos","byteStream","set","writeString","connectFlags","cleanSession","writeUint16","keepAliveInterval","decodeMessage","input","startingPos","messageInfo","digit","multiplier","endPos","wireMessage","connectAcknowledgeFlags","sessionPresent","returnCode","len","readUint16","topicName","parseUTF8","message","Message","subarray","offset","utf8Length","stringToUTF8","number","output","Array","numBytes","charCode","charCodeAt","lowCharCode","isNaN","utf16","byte1","byte2","toString","byte3","byte4","String","fromCharCode","Pinger","client","window","_client","_window","_keepAliveInterval","isReset","pingReq","doTimeout","pinger","doPing","_trace","_disconnected","socket","send","timeout","setTimeout","reset","clearTimeout","cancel","Timeout","timeoutSeconds","action","args","ClientImpl","uri","host","port","path","WebSocket","localStorage","_wsuri","_localKey","_msg_queue","_buffered_msg_queue","_sentMessages","_receivedMessages","_notify_msg_sent","_message_identifier","_sequence","restore","connected","maxMessageIdentifier","connectOptions","hostIndex","onConnected","onConnectionLost","onMessageDelivered","onMessageArrived","traceFunction","_connectTimeout","sendPinger","receivePinger","_reconnectInterval","_reconnecting","_reconnectTimeout","disconnectedPublishing","disconnectedBufferSize","receiveBuffer","_traceBuffer","_MAX_TRACE_ENTRIES","connect","connectOptionsMasked","_traceMask","uris","_doConnect","subscribe","filter","subscribeOptions","onSuccess","grantedQos","invocationContext","onFailure","errorCode","errorMessage","timeOut","_requires_ack","_schedule_message","unsubscribe","unsubscribeOptions","callback","messageCount","Object","sequence","push","disconnect","getTraceLog","Date","startTrace","stopTrace","wsurl","useSSL","uriParts","split","join","binaryType","onopen","_on_socket_open","onmessage","_on_socket_message","onerror","_on_socket_error","onclose","_on_socket_close","_process_queue","store","prefix","storedMessage","pubRecReceived","hex","messageBytes","payloadHex","setItem","JSON","stringify","value","getItem","parse","x","parseInt","fifo","reverse","pop","_socket_send","event","data","messages","_deframeMessages","_handleMessage","byteArray","newData","result","errorStack","stack","sentMessage","removeItem","receivedMessage","sequencedMessages","msgId","msg","sort","a","b","pubRelMessage","reconnected","_connected","_receivePublish","_receiveMessage","pubCompMessage","wireMessageMasked","pubAckMessage","pubRecMessage","wireMmessage","reconnect","_reconnect","errorText","readyState","close","mqttVersionExplicit","splice","record","slice","call","severity","max","shift","traceObject","masked","traceObjectMasked","attr","Client","match","ipv6AddSBracket","clientIdLength","_getHost","_setHost","_getPort","_setPort","_getPath","_setPath","_getURI","_setURI","_getClientId","_setClientId","_getOnConnected","_setOnConnected","newOnConnected","_getDisconnectedPublishing","_setDisconnectedPublishing","newDisconnectedPublishing","_getDisconnectedBufferSize","_setDisconnectedBufferSize","newDisconnectedBufferSize","_getOnConnectionLost","_setOnConnectionLost","newOnConnectionLost","_getOnMessageDelivered","_setOnMessageDelivered","newOnMessageDelivered","_getOnMessageArrived","_setOnMessageArrived","newOnMessageArrived","_getTrace","_setTrace","trace","hosts","ports","stringPayload","usingURIs","test","ipv6","topic","payload","publish","console","log","isConnected","newHost","newPort","newPath","newClientId","newTraceFunction","newPayload","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_getPayloadString","_getPayloadBytes","_getDestinationName","_setDestinationName","newDestinationName","_getQos","_setQos","newQos","_getRetained","_setRetained","newRetained","_getDuplicate","_setDuplicate","newDuplicate","payloadString","newTopic"],"mappings":"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","sourcesContent":["/* eslint-disable */\r\n/*******************************************************************************\r\n * Copyright (c) 2013 IBM Corp.\r\n *\r\n * All rights reserved. This program and the accompanying materials\r\n * are made available under the terms of the Eclipse Public License v1.0\r\n * and Eclipse Distribution License v1.0 which accompany this distribution.\r\n *\r\n * The Eclipse Public License is available at\r\n *    http://www.eclipse.org/legal/epl-v10.html\r\n * and the Eclipse Distribution License is available at\r\n *   http://www.eclipse.org/org/documents/edl-v10.php.\r\n *\r\n * Contributors:\r\n *    Andrew Banks - initial API and implementation and initial documentation\r\n *******************************************************************************/\r\n\r\n\r\n// Only expose a single object name in the global namespace.\r\n// Everything must go through this module. Global Paho.MQTT module\r\n// only has a single public function, client, which returns\r\n// a Paho.MQTT client object given connection details.\r\n\r\n/**\r\n * Send and receive messages using web browsers.\r\n * <p>\r\n * This programming interface lets a JavaScript client application use the MQTT V3.1 or\r\n * V3.1.1 protocol to connect to an MQTT-supporting messaging server.\r\n *\r\n * The function supported includes:\r\n * <ol>\r\n * <li>Connecting to and disconnecting from a server. The server is identified by its host name and port number.\r\n * <li>Specifying options that relate to the communications link with the server,\r\n * for example the frequency of keep-alive heartbeats, and whether SSL/TLS is required.\r\n * <li>Subscribing to and receiving messages from MQTT Topics.\r\n * <li>Publishing messages to MQTT Topics.\r\n * </ol>\r\n * <p>\r\n * The API consists of two main objects:\r\n * <dl>\r\n * <dt><b>{@link Paho.MQTT.Client}</b></dt>\r\n * <dd>This contains methods that provide the functionality of the API,\r\n * including provision of callbacks that notify the application when a message\r\n * arrives from or is delivered to the messaging server,\r\n * or when the status of its connection to the messaging server changes.</dd>\r\n * <dt><b>{@link Paho.MQTT.Message}</b></dt>\r\n * <dd>This encapsulates the payload of the message along with various attributes\r\n * associated with its delivery, in particular the destination to which it has\r\n * been (or is about to be) sent.</dd>\r\n * </dl>\r\n * <p>\r\n * The programming interface validates parameters passed to it, and will throw\r\n * an Error containing an error message intended for developer use, if it detects\r\n * an error with any parameter.\r\n * <p>\r\n * Example:\r\n *\r\n * <code><pre>\r\nclient = new Paho.MQTT.Client(location.hostname, Number(location.port), \"clientId\");\r\nclient.onConnectionLost = onConnectionLost;\r\nclient.onMessageArrived = onMessageArrived;\r\nclient.connect({onSuccess:onConnect});\r\n\r\nfunction onConnect() {\r\n  // Once a connection has been made, make a subscription and send a message.\r\n  console.log(\"onConnect\");\r\n  client.subscribe(\"/World\");\r\n  message = new Paho.MQTT.Message(\"Hello\");\r\n  message.destinationName = \"/World\";\r\n  client.send(message);\r\n};\r\nfunction onConnectionLost(responseObject) {\r\n  if (responseObject.errorCode !== 0)\r\n    console.log(\"onConnectionLost:\"+responseObject.errorMessage);\r\n};\r\nfunction onMessageArrived(message) {\r\n  console.log(\"onMessageArrived:\"+message.payloadString);\r\n  client.disconnect();\r\n};\r\n * </pre></code>\r\n * @namespace Paho.MQTT\r\n */\r\n\r\n/* jshint shadow:true */\r\n// (function ExportLibrary(root, factory) {\r\n//  if(typeof exports === 'object' && typeof module === 'object'){\r\n//      module.exports = factory();\r\n//  } else if (typeof define === 'function' && define.amd){\r\n//      define(factory);\r\n//  } else if (typeof exports === 'object'){\r\n//      exports = factory();\r\n//  } else {\r\n//      if (typeof root.Paho === 'undefined'){\r\n//          root.Paho = {};\r\n//      }\r\n//      root.Paho.MQTT = factory();\r\n//  }\r\n// })(this, function LibraryFactory(){\r\n\r\n    if (typeof Paho === \"undefined\") {\r\n        var Paho = {};\r\n    }\r\n    \r\n    Paho.MQTT = (function(global) {\r\n    \r\n        // Private variables below, these are only visible inside the function closure\r\n        // which is used to define the module.\r\n    \r\n        var version = \"@VERSION@\";\r\n        var buildLevel = \"@BUILDLEVEL@\";\r\n    \r\n        /**\r\n         * Unique message type identifiers, with associated\r\n         * associated integer values.\r\n         * @private\r\n         */\r\n        var MESSAGE_TYPE = {\r\n            CONNECT: 1,\r\n            CONNACK: 2,\r\n            PUBLISH: 3,\r\n            PUBACK: 4,\r\n            PUBREC: 5,\r\n            PUBREL: 6,\r\n            PUBCOMP: 7,\r\n            SUBSCRIBE: 8,\r\n            SUBACK: 9,\r\n            UNSUBSCRIBE: 10,\r\n            UNSUBACK: 11,\r\n            PINGREQ: 12,\r\n            PINGRESP: 13,\r\n            DISCONNECT: 14\r\n        };\r\n    \r\n        // Collection of utility methods used to simplify module code\r\n        // and promote the DRY pattern.\r\n    \r\n        /**\r\n         * Validate an object's parameter names to ensure they\r\n         * match a list of expected variables name for this option\r\n         * type. Used to ensure option object passed into the API don't\r\n         * contain erroneous parameters.\r\n         * @param {Object} obj - User options object\r\n         * @param {Object} keys - valid keys and types that may exist in obj.\r\n         * @throws {Error} Invalid option parameter found.\r\n         * @private\r\n         */\r\n        var validate = function(obj, keys) {\r\n            for (var key in obj) {\r\n                if (obj.hasOwnProperty(key)) {\r\n                    if (keys.hasOwnProperty(key)) {\r\n                        if (typeof obj[key] !== keys[key])\r\n                            throw new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));\r\n                    } else {\r\n                        var errorStr = \"Unknown property, \" + key + \". Valid properties are:\";\r\n                        for (var validKey in keys)\r\n                            if (keys.hasOwnProperty(validKey))\r\n                                errorStr = errorStr + \" \" + validKey;\r\n                        throw new Error(errorStr);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    \r\n        /**\r\n         * Return a new function which runs the user function bound\r\n         * to a fixed scope.\r\n         * @param {function} User function\r\n         * @param {object} Function scope\r\n         * @return {function} User function bound to another scope\r\n         * @private\r\n         */\r\n        var scope = function(f, scope) {\r\n            return function() {\r\n                return f.apply(scope, arguments);\r\n            };\r\n        };\r\n    \r\n        /**\r\n         * Unique message type identifiers, with associated\r\n         * associated integer values.\r\n         * @private\r\n         */\r\n        var ERROR = {\r\n            OK: { code: 0, text: \"AMQJSC0000I OK.\" },\r\n            CONNECT_TIMEOUT: { code: 1, text: \"AMQJSC0001E Connect timed out.\" },\r\n            SUBSCRIBE_TIMEOUT: { code: 2, text: \"AMQJS0002E Subscribe timed out.\" },\r\n            UNSUBSCRIBE_TIMEOUT: { code: 3, text: \"AMQJS0003E Unsubscribe timed out.\" },\r\n            PING_TIMEOUT: { code: 4, text: \"AMQJS0004E Ping timed out.\" },\r\n            INTERNAL_ERROR: { code: 5, text: \"AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}\" },\r\n            CONNACK_RETURNCODE: { code: 6, text: \"AMQJS0006E Bad Connack return code:{0} {1}.\" },\r\n            SOCKET_ERROR: { code: 7, text: \"AMQJS0007E Socket error:{0}.\" },\r\n            SOCKET_CLOSE: { code: 8, text: \"AMQJS0008I Socket closed.\" },\r\n            MALFORMED_UTF: { code: 9, text: \"AMQJS0009E Malformed UTF data:{0} {1} {2}.\" },\r\n            UNSUPPORTED: { code: 10, text: \"AMQJS0010E {0} is not supported by this browser.\" },\r\n            INVALID_STATE: { code: 11, text: \"AMQJS0011E Invalid state {0}.\" },\r\n            INVALID_TYPE: { code: 12, text: \"AMQJS0012E Invalid type {0} for {1}.\" },\r\n            INVALID_ARGUMENT: { code: 13, text: \"AMQJS0013E Invalid argument {0} for {1}.\" },\r\n            UNSUPPORTED_OPERATION: { code: 14, text: \"AMQJS0014E Unsupported operation.\" },\r\n            INVALID_STORED_DATA: { code: 15, text: \"AMQJS0015E Invalid data in local storage key={0} value={1}.\" },\r\n            INVALID_MQTT_MESSAGE_TYPE: { code: 16, text: \"AMQJS0016E Invalid MQTT message type {0}.\" },\r\n            MALFORMED_UNICODE: { code: 17, text: \"AMQJS0017E Malformed Unicode string:{0} {1}.\" },\r\n            BUFFER_FULL: { code: 18, text: \"AMQJS0018E Message buffer is full, maximum buffer size: {0}.\" },\r\n        };\r\n    \r\n        /** CONNACK RC Meaning. */\r\n        var CONNACK_RC = {\r\n            0: \"Connection Accepted\",\r\n            1: \"Connection Refused: unacceptable protocol version\",\r\n            2: \"Connection Refused: identifier rejected\",\r\n            3: \"Connection Refused: server unavailable\",\r\n            4: \"Connection Refused: bad user name or password\",\r\n            5: \"Connection Refused: not authorized\"\r\n        };\r\n    \r\n        /**\r\n         * Format an error message text.\r\n         * @private\r\n         * @param {error} ERROR.KEY value above.\r\n         * @param {substitutions} [array] substituted into the text.\r\n         * @return the text with the substitutions made.\r\n         */\r\n        var format = function(error, substitutions) {\r\n            var text = error.text;\r\n            if (substitutions) {\r\n                var field, start;\r\n                for (var i = 0; i < substitutions.length; i++) {\r\n                    field = \"{\" + i + \"}\";\r\n                    start = text.indexOf(field);\r\n                    if (start > 0) {\r\n                        var part1 = text.substring(0, start);\r\n                        var part2 = text.substring(start + field.length);\r\n                        text = part1 + substitutions[i] + part2;\r\n                    }\r\n                }\r\n            }\r\n            return text;\r\n        };\r\n    \r\n        //MQTT protocol and version          6    M    Q    I    s    d    p    3\r\n        var MqttProtoIdentifierv3 = [0x00, 0x06, 0x4d, 0x51, 0x49, 0x73, 0x64, 0x70, 0x03];\r\n        //MQTT proto/version for 311         4    M    Q    T    T    4\r\n        var MqttProtoIdentifierv4 = [0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04];\r\n    \r\n        /**\r\n         * Construct an MQTT wire protocol message.\r\n         * @param type MQTT packet type.\r\n         * @param options optional wire message attributes.\r\n         *\r\n         * Optional properties\r\n         *\r\n         * messageIdentifier: message ID in the range [0..65535]\r\n         * payloadMessage:  Application Message - PUBLISH only\r\n         * connectStrings:  array of 0 or more Strings to be put into the CONNECT payload\r\n         * topics:          array of strings (SUBSCRIBE, UNSUBSCRIBE)\r\n         * requestQoS:      array of QoS values [0..2]\r\n         *\r\n         * \"Flag\" properties\r\n         * cleanSession:    true if present / false if absent (CONNECT)\r\n         * willMessage:     true if present / false if absent (CONNECT)\r\n         * isRetained:      true if present / false if absent (CONNECT)\r\n         * userName:        true if present / false if absent (CONNECT)\r\n         * password:        true if present / false if absent (CONNECT)\r\n         * keepAliveInterval:   integer [0..65535]  (CONNECT)\r\n         *\r\n         * @private\r\n         * @ignore\r\n         */\r\n        var WireMessage = function(type, options) {\r\n            this.type = type;\r\n            for (var name in options) {\r\n                if (options.hasOwnProperty(name)) {\r\n                    this[name] = options[name];\r\n                }\r\n            }\r\n        };\r\n    \r\n        WireMessage.prototype.encode = function() {\r\n            // Compute the first byte of the fixed header\r\n            var first = ((this.type & 0x0f) << 4);\r\n    \r\n            /*\r\n             * Now calculate the length of the variable header + payload by adding up the lengths\r\n             * of all the component parts\r\n             */\r\n    \r\n            var remLength = 0;\r\n            var topicStrLength = [];\r\n            var destinationNameLength = 0;\r\n            var willMessagePayloadBytes;\r\n    \r\n            // if the message contains a messageIdentifier then we need two bytes for that\r\n            if (this.messageIdentifier !== undefined)\r\n                remLength += 2;\r\n    \r\n            switch (this.type) {\r\n                // If this a Connect then we need to include 12 bytes for its header\r\n                case MESSAGE_TYPE.CONNECT:\r\n                    switch (this.mqttVersion) {\r\n                        case 3:\r\n                            remLength += MqttProtoIdentifierv3.length + 3;\r\n                            break;\r\n                        case 4:\r\n                            remLength += MqttProtoIdentifierv4.length + 3;\r\n                            break;\r\n                    }\r\n    \r\n                    remLength += UTF8Length(this.clientId) + 2;\r\n                    if (this.willMessage !== undefined) {\r\n                        remLength += UTF8Length(this.willMessage.destinationName) + 2;\r\n                        // Will message is always a string, sent as UTF-8 characters with a preceding length.\r\n                        willMessagePayloadBytes = this.willMessage.payloadBytes;\r\n                        if (!(willMessagePayloadBytes instanceof Uint8Array))\r\n                            willMessagePayloadBytes = new Uint8Array(payloadBytes);\r\n                        remLength += willMessagePayloadBytes.byteLength + 2;\r\n                    }\r\n                    if (this.userName !== undefined)\r\n                        remLength += UTF8Length(this.userName) + 2;\r\n                    if (this.password !== undefined)\r\n                        remLength += UTF8Length(this.password) + 2;\r\n                    break;\r\n    \r\n                    // Subscribe, Unsubscribe can both contain topic strings\r\n                case MESSAGE_TYPE.SUBSCRIBE:\r\n                    first |= 0x02; // Qos = 1;\r\n                    for (var i = 0; i < this.topics.length; i++) {\r\n                        topicStrLength[i] = UTF8Length(this.topics[i]);\r\n                        remLength += topicStrLength[i] + 2;\r\n                    }\r\n                    remLength += this.requestedQos.length; // 1 byte for each topic's Qos\r\n                    // QoS on Subscribe only\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.UNSUBSCRIBE:\r\n                    first |= 0x02; // Qos = 1;\r\n                    for (var i = 0; i < this.topics.length; i++) {\r\n                        topicStrLength[i] = UTF8Length(this.topics[i]);\r\n                        remLength += topicStrLength[i] + 2;\r\n                    }\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.PUBREL:\r\n                    first |= 0x02; // Qos = 1;\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.PUBLISH:\r\n                    if (this.payloadMessage.duplicate) first |= 0x08;\r\n                    first = first |= (this.payloadMessage.qos << 1);\r\n                    if (this.payloadMessage.retained) first |= 0x01;\r\n                    destinationNameLength = UTF8Length(this.payloadMessage.destinationName);\r\n                    remLength += destinationNameLength + 2;\r\n                    var payloadBytes = this.payloadMessage.payloadBytes;\r\n                    remLength += payloadBytes.byteLength;\r\n                    if (payloadBytes instanceof ArrayBuffer)\r\n                        payloadBytes = new Uint8Array(payloadBytes);\r\n                    else if (!(payloadBytes instanceof Uint8Array))\r\n                        payloadBytes = new Uint8Array(payloadBytes.buffer);\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.DISCONNECT:\r\n                    break;\r\n    \r\n                default:\r\n                    break;\r\n            }\r\n    \r\n            // Now we can allocate a buffer for the message\r\n    \r\n            var mbi = encodeMBI(remLength); // Convert the length to MQTT MBI format\r\n            var pos = mbi.length + 1; // Offset of start of variable header\r\n            var buffer = new ArrayBuffer(remLength + pos);\r\n            var byteStream = new Uint8Array(buffer); // view it as a sequence of bytes\r\n    \r\n            //Write the fixed header into the buffer\r\n            byteStream[0] = first;\r\n            byteStream.set(mbi, 1);\r\n    \r\n            // If this is a PUBLISH then the variable header starts with a topic\r\n            if (this.type == MESSAGE_TYPE.PUBLISH)\r\n                pos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);\r\n            // If this is a CONNECT then the variable header contains the protocol name/version, flags and keepalive time\r\n    \r\n            else if (this.type == MESSAGE_TYPE.CONNECT) {\r\n                switch (this.mqttVersion) {\r\n                    case 3:\r\n                        byteStream.set(MqttProtoIdentifierv3, pos);\r\n                        pos += MqttProtoIdentifierv3.length;\r\n                        break;\r\n                    case 4:\r\n                        byteStream.set(MqttProtoIdentifierv4, pos);\r\n                        pos += MqttProtoIdentifierv4.length;\r\n                        break;\r\n                }\r\n                var connectFlags = 0;\r\n                if (this.cleanSession)\r\n                    connectFlags = 0x02;\r\n                if (this.willMessage !== undefined) {\r\n                    connectFlags |= 0x04;\r\n                    connectFlags |= (this.willMessage.qos << 3);\r\n                    if (this.willMessage.retained) {\r\n                        connectFlags |= 0x20;\r\n                    }\r\n                }\r\n                if (this.userName !== undefined)\r\n                    connectFlags |= 0x80;\r\n                if (this.password !== undefined)\r\n                    connectFlags |= 0x40;\r\n                byteStream[pos++] = connectFlags;\r\n                pos = writeUint16(this.keepAliveInterval, byteStream, pos);\r\n            }\r\n    \r\n            // Output the messageIdentifier - if there is one\r\n            if (this.messageIdentifier !== undefined)\r\n                pos = writeUint16(this.messageIdentifier, byteStream, pos);\r\n    \r\n            switch (this.type) {\r\n                case MESSAGE_TYPE.CONNECT:\r\n                    pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);\r\n                    if (this.willMessage !== undefined) {\r\n                        pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);\r\n                        pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\r\n                        byteStream.set(willMessagePayloadBytes, pos);\r\n                        pos += willMessagePayloadBytes.byteLength;\r\n    \r\n                    }\r\n                    if (this.userName !== undefined)\r\n                        pos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);\r\n                    if (this.password !== undefined)\r\n                        pos = writeString(this.password, UTF8Length(this.password), byteStream, pos);\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.PUBLISH:\r\n                    // PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\r\n                    byteStream.set(payloadBytes, pos);\r\n    \r\n                    break;\r\n    \r\n                    //          case MESSAGE_TYPE.PUBREC:\r\n                    //          case MESSAGE_TYPE.PUBREL:\r\n                    //          case MESSAGE_TYPE.PUBCOMP:\r\n                    //              break;\r\n    \r\n                case MESSAGE_TYPE.SUBSCRIBE:\r\n                    // SUBSCRIBE has a list of topic strings and request QoS\r\n                    for (var i = 0; i < this.topics.length; i++) {\r\n                        pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\r\n                        byteStream[pos++] = this.requestedQos[i];\r\n                    }\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.UNSUBSCRIBE:\r\n                    // UNSUBSCRIBE has a list of topic strings\r\n                    for (var i = 0; i < this.topics.length; i++)\r\n                        pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\r\n                    break;\r\n    \r\n                default:\r\n                    // Do nothing.\r\n            }\r\n    \r\n            return buffer;\r\n        };\r\n    \r\n        function decodeMessage(input, pos) {\r\n            var startingPos = pos;\r\n            var first = input[pos];\r\n            var type = first >> 4;\r\n            var messageInfo = first &= 0x0f;\r\n            pos += 1;\r\n    \r\n    \r\n            // Decode the remaining length (MBI format)\r\n    \r\n            var digit;\r\n            var remLength = 0;\r\n            var multiplier = 1;\r\n            do {\r\n                if (pos == input.length) {\r\n                    return [null, startingPos];\r\n                }\r\n                digit = input[pos++];\r\n                remLength += ((digit & 0x7F) * multiplier);\r\n                multiplier *= 128;\r\n            } while ((digit & 0x80) !== 0);\r\n    \r\n            var endPos = pos + remLength;\r\n            if (endPos > input.length) {\r\n                return [null, startingPos];\r\n            }\r\n    \r\n            var wireMessage = new WireMessage(type);\r\n            switch (type) {\r\n                case MESSAGE_TYPE.CONNACK:\r\n                    var connectAcknowledgeFlags = input[pos++];\r\n                    if (connectAcknowledgeFlags & 0x01)\r\n                        wireMessage.sessionPresent = true;\r\n                    wireMessage.returnCode = input[pos++];\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.PUBLISH:\r\n                    var qos = (messageInfo >> 1) & 0x03;\r\n    \r\n                    var len = readUint16(input, pos);\r\n                    pos += 2;\r\n                    var topicName = parseUTF8(input, pos, len);\r\n                    pos += len;\r\n                    // If QoS 1 or 2 there will be a messageIdentifier\r\n                    if (qos > 0) {\r\n                        wireMessage.messageIdentifier = readUint16(input, pos);\r\n                        pos += 2;\r\n                    }\r\n    \r\n                    var message = new Paho.MQTT.Message(input.subarray(pos, endPos));\r\n                    if ((messageInfo & 0x01) == 0x01)\r\n                        message.retained = true;\r\n                    if ((messageInfo & 0x08) == 0x08)\r\n                        message.duplicate = true;\r\n                    message.qos = qos;\r\n                    message.destinationName = topicName;\r\n                    wireMessage.payloadMessage = message;\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.PUBACK:\r\n                case MESSAGE_TYPE.PUBREC:\r\n                case MESSAGE_TYPE.PUBREL:\r\n                case MESSAGE_TYPE.PUBCOMP:\r\n                case MESSAGE_TYPE.UNSUBACK:\r\n                    wireMessage.messageIdentifier = readUint16(input, pos);\r\n                    break;\r\n    \r\n                case MESSAGE_TYPE.SUBACK:\r\n                    wireMessage.messageIdentifier = readUint16(input, pos);\r\n                    pos += 2;\r\n                    wireMessage.returnCode = input.subarray(pos, endPos);\r\n                    break;\r\n    \r\n                default:\r\n                    break;\r\n            }\r\n    \r\n            return [wireMessage, endPos];\r\n        }\r\n    \r\n        function writeUint16(input, buffer, offset) {\r\n            buffer[offset++] = input >> 8; //MSB\r\n            buffer[offset++] = input % 256; //LSB\r\n            return offset;\r\n        }\r\n    \r\n        function writeString(input, utf8Length, buffer, offset) {\r\n            offset = writeUint16(utf8Length, buffer, offset);\r\n            stringToUTF8(input, buffer, offset);\r\n            return offset + utf8Length;\r\n        }\r\n    \r\n        function readUint16(buffer, offset) {\r\n            return 256 * buffer[offset] + buffer[offset + 1];\r\n        }\r\n    \r\n        /**\r\n         * Encodes an MQTT Multi-Byte Integer\r\n         * @private\r\n         */\r\n        function encodeMBI(number) {\r\n            var output = new Array(1);\r\n            var numBytes = 0;\r\n    \r\n            do {\r\n                var digit = number % 128;\r\n                number = number >> 7;\r\n                if (number > 0) {\r\n                    digit |= 0x80;\r\n                }\r\n                output[numBytes++] = digit;\r\n            } while ((number > 0) && (numBytes < 4));\r\n    \r\n            return output;\r\n        }\r\n    \r\n        /**\r\n         * Takes a String and calculates its length in bytes when encoded in UTF8.\r\n         * @private\r\n         */\r\n        function UTF8Length(input) {\r\n            var output = 0;\r\n            for (var i = 0; i < input.length; i++) {\r\n                var charCode = input.charCodeAt(i);\r\n                if (charCode > 0x7FF) {\r\n                    // Surrogate pair means its a 4 byte character\r\n                    if (0xD800 <= charCode && charCode <= 0xDBFF) {\r\n                        i++;\r\n                        output++;\r\n                    }\r\n                    output += 3;\r\n                } else if (charCode > 0x7F)\r\n                    output += 2;\r\n                else\r\n                    output++;\r\n            }\r\n            return output;\r\n        }\r\n    \r\n        /**\r\n         * Takes a String and writes it into an array as UTF8 encoded bytes.\r\n         * @private\r\n         */\r\n        function stringToUTF8(input, output, start) {\r\n            var pos = start;\r\n            for (var i = 0; i < input.length; i++) {\r\n                var charCode = input.charCodeAt(i);\r\n    \r\n                // Check for a surrogate pair.\r\n                if (0xD800 <= charCode && charCode <= 0xDBFF) {\r\n                    var lowCharCode = input.charCodeAt(++i);\r\n                    if (isNaN(lowCharCode)) {\r\n                        throw new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));\r\n                    }\r\n                    charCode = ((charCode - 0xD800) << 10) + (lowCharCode - 0xDC00) + 0x10000;\r\n    \r\n                }\r\n    \r\n                if (charCode <= 0x7F) {\r\n                    output[pos++] = charCode;\r\n                } else if (charCode <= 0x7FF) {\r\n                    output[pos++] = charCode >> 6 & 0x1F | 0xC0;\r\n                    output[pos++] = charCode & 0x3F | 0x80;\r\n                } else if (charCode <= 0xFFFF) {\r\n                    output[pos++] = charCode >> 12 & 0x0F | 0xE0;\r\n                    output[pos++] = charCode >> 6 & 0x3F | 0x80;\r\n                    output[pos++] = charCode & 0x3F | 0x80;\r\n                } else {\r\n                    output[pos++] = charCode >> 18 & 0x07 | 0xF0;\r\n                    output[pos++] = charCode >> 12 & 0x3F | 0x80;\r\n                    output[pos++] = charCode >> 6 & 0x3F | 0x80;\r\n                    output[pos++] = charCode & 0x3F | 0x80;\r\n                }\r\n            }\r\n            return output;\r\n        }\r\n    \r\n        function parseUTF8(input, offset, length) {\r\n            var output = \"\";\r\n            var utf16;\r\n            var pos = offset;\r\n    \r\n            while (pos < offset + length) {\r\n                var byte1 = input[pos++];\r\n                if (byte1 < 128)\r\n                    utf16 = byte1;\r\n                else {\r\n                    var byte2 = input[pos++] - 128;\r\n                    if (byte2 < 0)\r\n                        throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), \"\"]));\r\n                    if (byte1 < 0xE0) // 2 byte character\r\n                        utf16 = 64 * (byte1 - 0xC0) + byte2;\r\n                    else {\r\n                        var byte3 = input[pos++] - 128;\r\n                        if (byte3 < 0)\r\n                            throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));\r\n                        if (byte1 < 0xF0) // 3 byte character\r\n                            utf16 = 4096 * (byte1 - 0xE0) + 64 * byte2 + byte3;\r\n                        else {\r\n                            var byte4 = input[pos++] - 128;\r\n                            if (byte4 < 0)\r\n                                throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\r\n                            if (byte1 < 0xF8) // 4 byte character\r\n                                utf16 = 262144 * (byte1 - 0xF0) + 4096 * byte2 + 64 * byte3 + byte4;\r\n                            else // longer encodings are not supported\r\n                                throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\r\n                        }\r\n                    }\r\n                }\r\n    \r\n                if (utf16 > 0xFFFF) // 4 byte character - express as a surrogate pair\r\n                {\r\n                    utf16 -= 0x10000;\r\n                    output += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character\r\n                    utf16 = 0xDC00 + (utf16 & 0x3FF); // trail character\r\n                }\r\n                output += String.fromCharCode(utf16);\r\n            }\r\n            return output;\r\n        }\r\n    \r\n        /**\r\n         * Repeat keepalive requests, monitor responses.\r\n         * @ignore\r\n         */\r\n        var Pinger = function(client, window, keepAliveInterval) {\r\n            this._client = client;\r\n            this._window = window;\r\n            this._keepAliveInterval = keepAliveInterval * 1000;\r\n            this.isReset = false;\r\n    \r\n            var pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();\r\n    \r\n            var doTimeout = function(pinger) {\r\n                return function() {\r\n                    return doPing.apply(pinger);\r\n                };\r\n            };\r\n    \r\n            /** @ignore */\r\n            var doPing = function() {\r\n                if (!this.isReset) {\r\n                    this._client._trace(\"Pinger.doPing\", \"Timed out\");\r\n                    this._client._disconnected(ERROR.PING_TIMEOUT.code, format(ERROR.PING_TIMEOUT));\r\n                } else {\r\n                    this.isReset = false;\r\n                    this._client._trace(\"Pinger.doPing\", \"send PINGREQ\");\r\n                    this._client.socket.send(pingReq);\r\n                    this.timeout = this._window.setTimeout(doTimeout(this), this._keepAliveInterval);\r\n                }\r\n            };\r\n    \r\n            this.reset = function() {\r\n                this.isReset = true;\r\n                this._window.clearTimeout(this.timeout);\r\n                if (this._keepAliveInterval > 0)\r\n                    this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\r\n            };\r\n    \r\n            this.cancel = function() {\r\n                this._window.clearTimeout(this.timeout);\r\n            };\r\n        };\r\n    \r\n        /**\r\n         * Monitor request completion.\r\n         * @ignore\r\n         */\r\n        var Timeout = function(client, window, timeoutSeconds, action, args) {\r\n            this._window = window;\r\n            if (!timeoutSeconds)\r\n                timeoutSeconds = 30;\r\n    \r\n            var doTimeout = function(action, client, args) {\r\n                return function() {\r\n                    return action.apply(client, args);\r\n                };\r\n            };\r\n            this.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);\r\n    \r\n            this.cancel = function() {\r\n                this._window.clearTimeout(this.timeout);\r\n            };\r\n        };\r\n    \r\n        /*\r\n         * Internal implementation of the Websockets MQTT V3.1 client.\r\n         *\r\n         * @name Paho.MQTT.ClientImpl @constructor\r\n         * @param {String} host the DNS nameof the webSocket host.\r\n         * @param {Number} port the port number for that host.\r\n         * @param {String} clientId the MQ client identifier.\r\n         */\r\n        var ClientImpl = function(uri, host, port, path, clientId) {\r\n            // Check dependencies are satisfied in this browser.\r\n            if (!(\"WebSocket\" in global && global.WebSocket !== null)) {\r\n                throw new Error(format(ERROR.UNSUPPORTED, [\"WebSocket\"]));\r\n            }\r\n            if (!(\"localStorage\" in global && global.localStorage !== null)) {\r\n                throw new Error(format(ERROR.UNSUPPORTED, [\"localStorage\"]));\r\n            }\r\n            if (!(\"ArrayBuffer\" in global && global.ArrayBuffer !== null)) {\r\n                throw new Error(format(ERROR.UNSUPPORTED, [\"ArrayBuffer\"]));\r\n            }\r\n            this._trace(\"Paho.MQTT.Client\", uri, host, port, path, clientId);\r\n    \r\n            this.host = host;\r\n            this.port = port;\r\n            this.path = path;\r\n            this.uri = uri;\r\n            this.clientId = clientId;\r\n            this._wsuri = null;\r\n    \r\n            // Local storagekeys are qualified with the following string.\r\n            // The conditional inclusion of path in the key is for backward\r\n            // compatibility to when the path was not configurable and assumed to\r\n            // be /mqtt\r\n            this._localKey = host + \":\" + port + (path != \"/mqtt\" ? \":\" + path : \"\") + \":\" + clientId + \":\";\r\n    \r\n            // Create private instance-only message queue\r\n            // Internal queue of messages to be sent, in sending order.\r\n            this._msg_queue = [];\r\n            this._buffered_msg_queue = [];\r\n    \r\n            // Messages we have sent and are expecting a response for, indexed by their respective message ids.\r\n            this._sentMessages = {};\r\n    \r\n            // Messages we have received and acknowleged and are expecting a confirm message for\r\n            // indexed by their respective message ids.\r\n            this._receivedMessages = {};\r\n    \r\n            // Internal list of callbacks to be executed when messages\r\n            // have been successfully sent over web socket, e.g. disconnect\r\n            // when it doesn't have to wait for ACK, just message is dispatched.\r\n            this._notify_msg_sent = {};\r\n    \r\n            // Unique identifier for SEND messages, incrementing\r\n            // counter as messages are sent.\r\n            this._message_identifier = 1;\r\n    \r\n            // Used to determine the transmission sequence of stored sent messages.\r\n            this._sequence = 0;\r\n    \r\n    \r\n            // Load the local state, if any, from the saved version, only restore state relevant to this client.\r\n            for (var key in localStorage)\r\n                if (key.indexOf(\"Sent:\" + this._localKey) === 0 || key.indexOf(\"Received:\" + this._localKey) === 0)\r\n                    this.restore(key);\r\n        };\r\n    \r\n        // Messaging Client public instance members.\r\n        ClientImpl.prototype.host = null;\r\n        ClientImpl.prototype.port = null;\r\n        ClientImpl.prototype.path = null;\r\n        ClientImpl.prototype.uri = null;\r\n        ClientImpl.prototype.clientId = null;\r\n    \r\n        // Messaging Client private instance members.\r\n        ClientImpl.prototype.socket = null;\r\n        /* true once we have received an acknowledgement to a CONNECT packet. */\r\n        ClientImpl.prototype.connected = false;\r\n        /* The largest message identifier allowed, may not be larger than 2**16 but\r\n         * if set smaller reduces the maximum number of outbound messages allowed.\r\n         */\r\n        ClientImpl.prototype.maxMessageIdentifier = 65536;\r\n        ClientImpl.prototype.connectOptions = null;\r\n        ClientImpl.prototype.hostIndex = null;\r\n        ClientImpl.prototype.onConnected = null;\r\n        ClientImpl.prototype.onConnectionLost = null;\r\n        ClientImpl.prototype.onMessageDelivered = null;\r\n        ClientImpl.prototype.onMessageArrived = null;\r\n        ClientImpl.prototype.traceFunction = null;\r\n        ClientImpl.prototype._msg_queue = null;\r\n        ClientImpl.prototype._buffered_msg_queue = null;\r\n        ClientImpl.prototype._connectTimeout = null;\r\n        /* The sendPinger monitors how long we allow before we send data to prove to the server that we are alive. */\r\n        ClientImpl.prototype.sendPinger = null;\r\n        /* The receivePinger monitors how long we allow before we require evidence that the server is alive. */\r\n        ClientImpl.prototype.receivePinger = null;\r\n        ClientImpl.prototype._reconnectInterval = 1; // Reconnect Delay, starts at 1 second\r\n        ClientImpl.prototype._reconnecting = false;\r\n        ClientImpl.prototype._reconnectTimeout = null;\r\n        ClientImpl.prototype.disconnectedPublishing = false;\r\n        ClientImpl.prototype.disconnectedBufferSize = 5000;\r\n    \r\n        ClientImpl.prototype.receiveBuffer = null;\r\n    \r\n        ClientImpl.prototype._traceBuffer = null;\r\n        ClientImpl.prototype._MAX_TRACE_ENTRIES = 100;\r\n    \r\n        ClientImpl.prototype.connect = function(connectOptions) {\r\n            var connectOptionsMasked = this._traceMask(connectOptions, \"password\");\r\n            this._trace(\"Client.connect\", connectOptionsMasked, this.socket, this.connected);\r\n    \r\n            if (this.connected)\r\n                throw new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\r\n            if (this.socket)\r\n                throw new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\r\n    \r\n            if (this._reconnecting) {\r\n                // connect() function is called while reconnect is in progress.\r\n                // Terminate the auto reconnect process to use new connect options.\r\n                this._reconnectTimeout.cancel();\r\n                this._reconnectTimeout = null;\r\n                this._reconnecting = false;\r\n            }\r\n    \r\n            this.connectOptions = connectOptions;\r\n            this._reconnectInterval = 1;\r\n            this._reconnecting = false;\r\n            if (connectOptions.uris) {\r\n                this.hostIndex = 0;\r\n                this._doConnect(connectOptions.uris[0]);\r\n            } else {\r\n                this._doConnect(this.uri);\r\n            }\r\n    \r\n        };\r\n    \r\n        ClientImpl.prototype.subscribe = function(filter, subscribeOptions) {\r\n            this._trace(\"Client.subscribe\", filter, subscribeOptions);\r\n    \r\n            if (!this.connected)\r\n                throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\r\n    \r\n            var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\r\n            wireMessage.topics = [filter];\r\n            if (subscribeOptions.qos !== undefined)\r\n                wireMessage.requestedQos = [subscribeOptions.qos];\r\n            else\r\n                wireMessage.requestedQos = [0];\r\n    \r\n            if (subscribeOptions.onSuccess) {\r\n                wireMessage.onSuccess = function(grantedQos) { subscribeOptions.onSuccess({ invocationContext: subscribeOptions.invocationContext, grantedQos: grantedQos }); };\r\n            }\r\n    \r\n            if (subscribeOptions.onFailure) {\r\n                wireMessage.onFailure = function(errorCode) { subscribeOptions.onFailure({ invocationContext: subscribeOptions.invocationContext, errorCode: errorCode, errorMessage: format(errorCode) }); };\r\n            }\r\n    \r\n            if (subscribeOptions.timeout) {\r\n                wireMessage.timeOut = new Timeout(this, window, subscribeOptions.timeout, subscribeOptions.onFailure, [{\r\n                    invocationContext: subscribeOptions.invocationContext,\r\n                    errorCode: ERROR.SUBSCRIBE_TIMEOUT.code,\r\n                    errorMessage: format(ERROR.SUBSCRIBE_TIMEOUT)\r\n                }]);\r\n            }\r\n    \r\n            // All subscriptions return a SUBACK.\r\n            this._requires_ack(wireMessage);\r\n            this._schedule_message(wireMessage);\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype.unsubscribe = function(filter, unsubscribeOptions) {\r\n            this._trace(\"Client.unsubscribe\", filter, unsubscribeOptions);\r\n    \r\n            if (!this.connected)\r\n                throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\r\n    \r\n            var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\r\n            wireMessage.topics = [filter];\r\n    \r\n            if (unsubscribeOptions.onSuccess) {\r\n                wireMessage.callback = function() { unsubscribeOptions.onSuccess({ invocationContext: unsubscribeOptions.invocationContext }); };\r\n            }\r\n            if (unsubscribeOptions.timeout) {\r\n                wireMessage.timeOut = new Timeout(this, window, unsubscribeOptions.timeout, unsubscribeOptions.onFailure, [{\r\n                    invocationContext: unsubscribeOptions.invocationContext,\r\n                    errorCode: ERROR.UNSUBSCRIBE_TIMEOUT.code,\r\n                    errorMessage: format(ERROR.UNSUBSCRIBE_TIMEOUT)\r\n                }]);\r\n            }\r\n    \r\n            // All unsubscribes return a SUBACK.\r\n            this._requires_ack(wireMessage);\r\n            this._schedule_message(wireMessage);\r\n        };\r\n    \r\n        ClientImpl.prototype.send = function(message) {\r\n            this._trace(\"Client.send\", message);\r\n    \r\n            var wireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);\r\n            wireMessage.payloadMessage = message;\r\n    \r\n            if (this.connected) {\r\n                // Mark qos 1 & 2 message as \"ACK required\"\r\n                // For qos 0 message, invoke onMessageDelivered callback if there is one.\r\n                // Then schedule the message.\r\n                if (message.qos > 0) {\r\n                    this._requires_ack(wireMessage);\r\n                } else if (this.onMessageDelivered) {\r\n                    this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);\r\n                }\r\n                this._schedule_message(wireMessage);\r\n            } else {\r\n                // Currently disconnected, will not schedule this message\r\n                // Check if reconnecting is in progress and disconnected publish is enabled.\r\n                if (this._reconnecting && this.disconnectedPublishing) {\r\n                    // Check the limit which include the \"required ACK\" messages\r\n                    var messageCount = Object.keys(this._sentMessages).length + this._buffered_msg_queue.length;\r\n                    if (messageCount > this.disconnectedBufferSize) {\r\n                        throw new Error(format(ERROR.BUFFER_FULL, [this.disconnectedBufferSize]));\r\n                    } else {\r\n                        if (message.qos > 0) {\r\n                            // Mark this message as \"ACK required\"\r\n                            this._requires_ack(wireMessage);\r\n                        } else {\r\n                            wireMessage.sequence = ++this._sequence;\r\n                            this._buffered_msg_queue.push(wireMessage);\r\n                        }\r\n                    }\r\n                } else {\r\n                    throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\r\n                }\r\n            }\r\n        };\r\n    \r\n        ClientImpl.prototype.disconnect = function() {\r\n            this._trace(\"Client.disconnect\");\r\n    \r\n            if (this._reconnecting) {\r\n                // disconnect() function is called while reconnect is in progress.\r\n                // Terminate the auto reconnect process.\r\n                this._reconnectTimeout.cancel();\r\n                this._reconnectTimeout = null;\r\n                this._reconnecting = false;\r\n            }\r\n    \r\n            if (!this.socket)\r\n                throw new Error(format(ERROR.INVALID_STATE, [\"not connecting or connected\"]));\r\n    \r\n            wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);\r\n    \r\n            // Run the disconnected call back as soon as the message has been sent,\r\n            // in case of a failure later on in the disconnect processing.\r\n            // as a consequence, the _disconected call back may be run several times.\r\n            this._notify_msg_sent[wireMessage] = scope(this._disconnected, this);\r\n    \r\n            this._schedule_message(wireMessage);\r\n        };\r\n    \r\n        ClientImpl.prototype.getTraceLog = function() {\r\n            if (this._traceBuffer !== null) {\r\n                this._trace(\"Client.getTraceLog\", new Date());\r\n                this._trace(\"Client.getTraceLog in flight messages\", this._sentMessages.length);\r\n                for (var key in this._sentMessages)\r\n                    this._trace(\"_sentMessages \", key, this._sentMessages[key]);\r\n                for (var key in this._receivedMessages)\r\n                    this._trace(\"_receivedMessages \", key, this._receivedMessages[key]);\r\n    \r\n                return this._traceBuffer;\r\n            }\r\n        };\r\n    \r\n        ClientImpl.prototype.startTrace = function() {\r\n            if (this._traceBuffer === null) {\r\n                this._traceBuffer = [];\r\n            }\r\n            this._trace(\"Client.startTrace\", new Date(), version);\r\n        };\r\n    \r\n        ClientImpl.prototype.stopTrace = function() {\r\n            delete this._traceBuffer;\r\n        };\r\n    \r\n        ClientImpl.prototype._doConnect = function(wsurl) {\r\n            // When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.\r\n            if (this.connectOptions.useSSL) {\r\n                var uriParts = wsurl.split(\":\");\r\n                uriParts[0] = \"wss\";\r\n                wsurl = uriParts.join(\":\");\r\n            }\r\n            this._wsuri = wsurl;\r\n            this.connected = false;\r\n    \r\n    \r\n    \r\n            if (this.connectOptions.mqttVersion < 4) {\r\n                this.socket = new WebSocket(wsurl, [\"mqttv3.1\"]);\r\n            } else {\r\n                this.socket = new WebSocket(wsurl, [\"mqtt\"]);\r\n            }\r\n            this.socket.binaryType = 'arraybuffer';\r\n            this.socket.onopen = scope(this._on_socket_open, this);\r\n            this.socket.onmessage = scope(this._on_socket_message, this);\r\n            this.socket.onerror = scope(this._on_socket_error, this);\r\n            this.socket.onclose = scope(this._on_socket_close, this);\r\n    \r\n            this.sendPinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\r\n            this.receivePinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\r\n            if (this._connectTimeout) {\r\n                this._connectTimeout.cancel();\r\n                this._connectTimeout = null;\r\n            }\r\n            this._connectTimeout = new Timeout(this, window, this.connectOptions.timeout, this._disconnected, [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);\r\n        };\r\n    \r\n    \r\n        // Schedule a new message to be sent over the WebSockets\r\n        // connection. CONNECT messages cause WebSocket connection\r\n        // to be started. All other messages are queued internally\r\n        // until this has happened. When WS connection starts, process\r\n        // all outstanding messages.\r\n        ClientImpl.prototype._schedule_message = function(message) {\r\n            this._msg_queue.push(message);\r\n            // Process outstanding messages in the queue if we have an  open socket, and have received CONNACK.\r\n            if (this.connected) {\r\n                this._process_queue();\r\n            }\r\n        };\r\n    \r\n        ClientImpl.prototype.store = function(prefix, wireMessage) {\r\n            var storedMessage = { type: wireMessage.type, messageIdentifier: wireMessage.messageIdentifier, version: 1 };\r\n    \r\n            switch (wireMessage.type) {\r\n                case MESSAGE_TYPE.PUBLISH:\r\n                    if (wireMessage.pubRecReceived)\r\n                        storedMessage.pubRecReceived = true;\r\n    \r\n                    // Convert the payload to a hex string.\r\n                    storedMessage.payloadMessage = {};\r\n                    var hex = \"\";\r\n                    var messageBytes = wireMessage.payloadMessage.payloadBytes;\r\n                    for (var i = 0; i < messageBytes.length; i++) {\r\n                        if (messageBytes[i] <= 0xF)\r\n                            hex = hex + \"0\" + messageBytes[i].toString(16);\r\n                        else\r\n                            hex = hex + messageBytes[i].toString(16);\r\n                    }\r\n                    storedMessage.payloadMessage.payloadHex = hex;\r\n    \r\n                    storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;\r\n                    storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;\r\n                    if (wireMessage.payloadMessage.duplicate)\r\n                        storedMessage.payloadMessage.duplicate = true;\r\n                    if (wireMessage.payloadMessage.retained)\r\n                        storedMessage.payloadMessage.retained = true;\r\n    \r\n                    // Add a sequence number to sent messages.\r\n                    if (prefix.indexOf(\"Sent:\") === 0) {\r\n                        if (wireMessage.sequence === undefined)\r\n                            wireMessage.sequence = ++this._sequence;\r\n                        storedMessage.sequence = wireMessage.sequence;\r\n                    }\r\n                    break;\r\n    \r\n                default:\r\n                    throw Error(format(ERROR.INVALID_STORED_DATA, [key, storedMessage]));\r\n            }\r\n            localStorage.setItem(prefix + this._localKey + wireMessage.messageIdentifier, JSON.stringify(storedMessage));\r\n        };\r\n    \r\n        ClientImpl.prototype.restore = function(key) {\r\n            var value = localStorage.getItem(key);\r\n            var storedMessage = JSON.parse(value);\r\n    \r\n            var wireMessage = new WireMessage(storedMessage.type, storedMessage);\r\n    \r\n            switch (storedMessage.type) {\r\n                case MESSAGE_TYPE.PUBLISH:\r\n                    // Replace the payload message with a Message object.\r\n                    var hex = storedMessage.payloadMessage.payloadHex;\r\n                    var buffer = new ArrayBuffer((hex.length) / 2);\r\n                    var byteStream = new Uint8Array(buffer);\r\n                    var i = 0;\r\n                    while (hex.length >= 2) {\r\n                        var x = parseInt(hex.substring(0, 2), 16);\r\n                        hex = hex.substring(2, hex.length);\r\n                        byteStream[i++] = x;\r\n                    }\r\n                    var payloadMessage = new Paho.MQTT.Message(byteStream);\r\n    \r\n                    payloadMessage.qos = storedMessage.payloadMessage.qos;\r\n                    payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\r\n                    if (storedMessage.payloadMessage.duplicate)\r\n                        payloadMessage.duplicate = true;\r\n                    if (storedMessage.payloadMessage.retained)\r\n                        payloadMessage.retained = true;\r\n                    wireMessage.payloadMessage = payloadMessage;\r\n    \r\n                    break;\r\n    \r\n                default:\r\n                    throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\r\n            }\r\n    \r\n            if (key.indexOf(\"Sent:\" + this._localKey) === 0) {\r\n                wireMessage.payloadMessage.duplicate = true;\r\n                this._sentMessages[wireMessage.messageIdentifier] = wireMessage;\r\n            } else if (key.indexOf(\"Received:\" + this._localKey) === 0) {\r\n                this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\r\n            }\r\n        };\r\n    \r\n        ClientImpl.prototype._process_queue = function() {\r\n            var message = null;\r\n            // Process messages in order they were added\r\n            var fifo = this._msg_queue.reverse();\r\n    \r\n            // Send all queued messages down socket connection\r\n            while ((message = fifo.pop())) {\r\n                this._socket_send(message);\r\n                // Notify listeners that message was successfully sent\r\n                if (this._notify_msg_sent[message]) {\r\n                    this._notify_msg_sent[message]();\r\n                    delete this._notify_msg_sent[message];\r\n                }\r\n            }\r\n        };\r\n    \r\n        /**\r\n         * Expect an ACK response for this message. Add message to the set of in progress\r\n         * messages and set an unused identifier in this message.\r\n         * @ignore\r\n         */\r\n        ClientImpl.prototype._requires_ack = function(wireMessage) {\r\n            var messageCount = Object.keys(this._sentMessages).length;\r\n            if (messageCount > this.maxMessageIdentifier)\r\n                throw Error(\"Too many messages:\" + messageCount);\r\n    \r\n            while (this._sentMessages[this._message_identifier] !== undefined) {\r\n                this._message_identifier++;\r\n            }\r\n            wireMessage.messageIdentifier = this._message_identifier;\r\n            this._sentMessages[wireMessage.messageIdentifier] = wireMessage;\r\n            if (wireMessage.type === MESSAGE_TYPE.PUBLISH) {\r\n                this.store(\"Sent:\", wireMessage);\r\n            }\r\n            if (this._message_identifier === this.maxMessageIdentifier) {\r\n                this._message_identifier = 1;\r\n            }\r\n        };\r\n    \r\n        /**\r\n         * Called when the underlying websocket has been opened.\r\n         * @ignore\r\n         */\r\n        ClientImpl.prototype._on_socket_open = function() {\r\n            // Create the CONNECT message object.\r\n            var wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);\r\n            wireMessage.clientId = this.clientId;\r\n            this._socket_send(wireMessage);\r\n        };\r\n    \r\n        /**\r\n         * Called when the underlying websocket has received a complete packet.\r\n         * @ignore\r\n         */\r\n        ClientImpl.prototype._on_socket_message = function(event) {\r\n            this._trace(\"Client._on_socket_message\", event.data);\r\n            var messages = this._deframeMessages(event.data);\r\n            for (var i = 0; i < messages.length; i += 1) {\r\n                this._handleMessage(messages[i]);\r\n            }\r\n        };\r\n    \r\n        ClientImpl.prototype._deframeMessages = function(data) {\r\n            var byteArray = new Uint8Array(data);\r\n            var messages = [];\r\n            if (this.receiveBuffer) {\r\n                var newData = new Uint8Array(this.receiveBuffer.length + byteArray.length);\r\n                newData.set(this.receiveBuffer);\r\n                newData.set(byteArray, this.receiveBuffer.length);\r\n                byteArray = newData;\r\n                delete this.receiveBuffer;\r\n            }\r\n            try {\r\n                var offset = 0;\r\n                while (offset < byteArray.length) {\r\n                    var result = decodeMessage(byteArray, offset);\r\n                    var wireMessage = result[0];\r\n                    offset = result[1];\r\n                    if (wireMessage !== null) {\r\n                        messages.push(wireMessage);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                if (offset < byteArray.length) {\r\n                    this.receiveBuffer = byteArray.subarray(offset);\r\n                }\r\n            } catch (error) {\r\n                var errorStack = ((error.hasOwnProperty('stack') == 'undefined') ? error.stack.toString() : \"No Error Stack Available\");\r\n                this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));\r\n                return;\r\n            }\r\n            return messages;\r\n        };\r\n    \r\n        ClientImpl.prototype._handleMessage = function(wireMessage) {\r\n    \r\n            this._trace(\"Client._handleMessage\", wireMessage);\r\n    \r\n            try {\r\n                switch (wireMessage.type) {\r\n                    case MESSAGE_TYPE.CONNACK:\r\n                        this._connectTimeout.cancel();\r\n                        if (this._reconnectTimeout)\r\n                            this._reconnectTimeout.cancel();\r\n    \r\n                        // If we have started using clean session then clear up the local state.\r\n                        if (this.connectOptions.cleanSession) {\r\n                            for (var key in this._sentMessages) {\r\n                                var sentMessage = this._sentMessages[key];\r\n                                localStorage.removeItem(\"Sent:\" + this._localKey + sentMessage.messageIdentifier);\r\n                            }\r\n                            this._sentMessages = {};\r\n    \r\n                            for (var key in this._receivedMessages) {\r\n                                var receivedMessage = this._receivedMessages[key];\r\n                                localStorage.removeItem(\"Received:\" + this._localKey + receivedMessage.messageIdentifier);\r\n                            }\r\n                            this._receivedMessages = {};\r\n                        }\r\n                        // Client connected and ready for business.\r\n                        if (wireMessage.returnCode === 0) {\r\n    \r\n                            this.connected = true;\r\n                            // Jump to the end of the list of uris and stop looking for a good host.\r\n    \r\n                            if (this.connectOptions.uris)\r\n                                this.hostIndex = this.connectOptions.uris.length;\r\n    \r\n                        } else {\r\n                            this._disconnected(ERROR.CONNACK_RETURNCODE.code, format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\r\n                            break;\r\n                        }\r\n    \r\n                        // Resend messages.\r\n                        var sequencedMessages = [];\r\n                        for (var msgId in this._sentMessages) {\r\n                            if (this._sentMessages.hasOwnProperty(msgId))\r\n                                sequencedMessages.push(this._sentMessages[msgId]);\r\n                        }\r\n    \r\n                        // Also schedule qos 0 buffered messages if any\r\n                        if (this._buffered_msg_queue.length > 0) {\r\n                            var msg = null;\r\n                            var fifo = this._buffered_msg_queue.reverse();\r\n                            while ((msg = fifo.pop())) {\r\n                                sequencedMessages.push(msg);\r\n                                if (this.onMessageDelivered)\r\n                                    this._notify_msg_sent[msg] = this.onMessageDelivered(msg.payloadMessage);\r\n                            }\r\n                        }\r\n    \r\n                        // Sort sentMessages into the original sent order.\r\n                        var sequencedMessages = sequencedMessages.sort(function(a, b) { return a.sequence - b.sequence; });\r\n                        for (var i = 0, len = sequencedMessages.length; i < len; i++) {\r\n                            var sentMessage = sequencedMessages[i];\r\n                            if (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {\r\n                                var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier: sentMessage.messageIdentifier });\r\n                                this._schedule_message(pubRelMessage);\r\n                            } else {\r\n                                this._schedule_message(sentMessage);\r\n                            }\r\n                        }\r\n    \r\n                        // Execute the connectOptions.onSuccess callback if there is one.\r\n                        // Will also now return if this connection was the result of an automatic\r\n                        // reconnect and which URI was successfully connected to.\r\n                        if (this.connectOptions.onSuccess) {\r\n                            this.connectOptions.onSuccess({ invocationContext: this.connectOptions.invocationContext });\r\n                        }\r\n    \r\n                        var reconnected = false;\r\n                        if (this._reconnecting) {\r\n                            reconnected = true;\r\n                            this._reconnectInterval = 1;\r\n                            this._reconnecting = false;\r\n                        }\r\n    \r\n                        // Execute the onConnected callback if there is one.\r\n                        this._connected(reconnected, this._wsuri);\r\n    \r\n                        // Process all queued messages now that the connection is established.\r\n                        this._process_queue();\r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.PUBLISH:\r\n                        this._receivePublish(wireMessage);\r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.PUBACK:\r\n                        var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n                        // If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\r\n                        if (sentMessage) {\r\n                            delete this._sentMessages[wireMessage.messageIdentifier];\r\n                            localStorage.removeItem(\"Sent:\" + this._localKey + wireMessage.messageIdentifier);\r\n                            if (this.onMessageDelivered)\r\n                                this.onMessageDelivered(sentMessage.payloadMessage);\r\n                        }\r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.PUBREC:\r\n                        var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n                        // If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\r\n                        if (sentMessage) {\r\n                            sentMessage.pubRecReceived = true;\r\n                            var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier: wireMessage.messageIdentifier });\r\n                            this.store(\"Sent:\", sentMessage);\r\n                            this._schedule_message(pubRelMessage);\r\n                        }\r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.PUBREL:\r\n                        var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];\r\n                        localStorage.removeItem(\"Received:\" + this._localKey + wireMessage.messageIdentifier);\r\n                        // If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\r\n                        if (receivedMessage) {\r\n                            this._receiveMessage(receivedMessage);\r\n                            delete this._receivedMessages[wireMessage.messageIdentifier];\r\n                        }\r\n                        // Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\r\n                        var pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, { messageIdentifier: wireMessage.messageIdentifier });\r\n                        this._schedule_message(pubCompMessage);\r\n    \r\n    \r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.PUBCOMP:\r\n                        var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n                        delete this._sentMessages[wireMessage.messageIdentifier];\r\n                        localStorage.removeItem(\"Sent:\" + this._localKey + wireMessage.messageIdentifier);\r\n                        if (this.onMessageDelivered)\r\n                            this.onMessageDelivered(sentMessage.payloadMessage);\r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.SUBACK:\r\n                        var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n                        if (sentMessage) {\r\n                            if (sentMessage.timeOut)\r\n                                sentMessage.timeOut.cancel();\r\n                            // This will need to be fixed when we add multiple topic support\r\n                            if (wireMessage.returnCode[0] === 0x80) {\r\n                                if (sentMessage.onFailure) {\r\n                                    sentMessage.onFailure(wireMessage.returnCode);\r\n                                }\r\n                            } else if (sentMessage.onSuccess) {\r\n                                sentMessage.onSuccess(wireMessage.returnCode);\r\n                            }\r\n                            delete this._sentMessages[wireMessage.messageIdentifier];\r\n                        }\r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.UNSUBACK:\r\n                        var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\r\n                        if (sentMessage) {\r\n                            if (sentMessage.timeOut)\r\n                                sentMessage.timeOut.cancel();\r\n                            if (sentMessage.callback) {\r\n                                sentMessage.callback();\r\n                            }\r\n                            delete this._sentMessages[wireMessage.messageIdentifier];\r\n                        }\r\n    \r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.PINGRESP:\r\n                        /* The sendPinger or receivePinger may have sent a ping, the receivePinger has already been reset. */\r\n                        this.sendPinger.reset();\r\n                        break;\r\n    \r\n                    case MESSAGE_TYPE.DISCONNECT:\r\n                        // Clients do not expect to receive disconnect packets.\r\n                        this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\r\n                        break;\r\n    \r\n                    default:\r\n                        this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\r\n                }\r\n            } catch (error) {\r\n                var errorStack = ((error.hasOwnProperty('stack') == 'undefined') ? error.stack.toString() : \"No Error Stack Available\");\r\n                this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));\r\n                return;\r\n            }\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype._on_socket_error = function(error) {\r\n            if (!this._reconnecting) {\r\n                this._disconnected(ERROR.SOCKET_ERROR.code, format(ERROR.SOCKET_ERROR, [error.data]));\r\n            }\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype._on_socket_close = function() {\r\n            if (!this._reconnecting) {\r\n                this._disconnected(ERROR.SOCKET_CLOSE.code, format(ERROR.SOCKET_CLOSE));\r\n            }\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype._socket_send = function(wireMessage) {\r\n    \r\n            if (wireMessage.type == 1) {\r\n                var wireMessageMasked = this._traceMask(wireMessage, \"password\");\r\n                this._trace(\"Client._socket_send\", wireMessageMasked);\r\n            } else this._trace(\"Client._socket_send\", wireMessage);\r\n    \r\n            this.socket.send(wireMessage.encode());\r\n            /* We have proved to the server we are alive. */\r\n            this.sendPinger.reset();\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype._receivePublish = function(wireMessage) {\r\n            switch (wireMessage.payloadMessage.qos) {\r\n                case \"undefined\":\r\n                case 0:\r\n                    this._receiveMessage(wireMessage);\r\n                    break;\r\n    \r\n                case 1:\r\n                    var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, { messageIdentifier: wireMessage.messageIdentifier });\r\n                    this._schedule_message(pubAckMessage);\r\n                    this._receiveMessage(wireMessage);\r\n                    break;\r\n    \r\n                case 2:\r\n                    this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\r\n                    this.store(\"Received:\", wireMessage);\r\n                    var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, { messageIdentifier: wireMessage.messageIdentifier });\r\n                    this._schedule_message(pubRecMessage);\r\n    \r\n                    break;\r\n    \r\n                default:\r\n                    throw Error(\"Invaild qos=\" + wireMmessage.payloadMessage.qos);\r\n            }\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype._receiveMessage = function(wireMessage) {\r\n            if (this.onMessageArrived) {\r\n                this.onMessageArrived(wireMessage.payloadMessage);\r\n            }\r\n        };\r\n    \r\n        /**\r\n         * Client has connected.\r\n         * @param {reconnect} [boolean] indicate if this was a result of reconnect operation.\r\n         * @param {uri} [string] fully qualified WebSocket URI of the server.\r\n         */\r\n        ClientImpl.prototype._connected = function(reconnect, uri) {\r\n            // Execute the onConnected callback if there is one.\r\n            if (this.onConnected)\r\n                this.onConnected(reconnect, uri);\r\n        };\r\n    \r\n        /**\r\n         * Attempts to reconnect the client to the server.\r\n         * For each reconnect attempt, will double the reconnect interval\r\n         * up to 128 seconds.\r\n         */\r\n        ClientImpl.prototype._reconnect = function() {\r\n            this._trace(\"Client._reconnect\");\r\n            if (!this.connected) {\r\n                this._reconnecting = true;\r\n                this.sendPinger.cancel();\r\n                this.receivePinger.cancel();\r\n                if (this._reconnectInterval < 128)\r\n                    this._reconnectInterval = this._reconnectInterval * 2;\r\n                if (this.connectOptions.uris) {\r\n                    this.hostIndex = 0;\r\n                    this._doConnect(this.connectOptions.uris[0]);\r\n                } else {\r\n                    this._doConnect(this.uri);\r\n                }\r\n            }\r\n        };\r\n    \r\n        /**\r\n         * Client has disconnected either at its own request or because the server\r\n         * or network disconnected it. Remove all non-durable state.\r\n         * @param {errorCode} [number] the error number.\r\n         * @param {errorText} [string] the error text.\r\n         * @ignore\r\n         */\r\n        ClientImpl.prototype._disconnected = function(errorCode, errorText) {\r\n            this._trace(\"Client._disconnected\", errorCode, errorText);\r\n    \r\n            if (errorCode !== undefined && this._reconnecting) {\r\n                //Continue automatic reconnect process\r\n                this._reconnectTimeout = new Timeout(this, window, this._reconnectInterval, this._reconnect);\r\n                return;\r\n            }\r\n    \r\n            this.sendPinger.cancel();\r\n            this.receivePinger.cancel();\r\n            if (this._connectTimeout) {\r\n                this._connectTimeout.cancel();\r\n                this._connectTimeout = null;\r\n            }\r\n    \r\n            // Clear message buffers.\r\n            this._msg_queue = [];\r\n            this._buffered_msg_queue = [];\r\n            this._notify_msg_sent = {};\r\n    \r\n            if (this.socket) {\r\n                // Cancel all socket callbacks so that they cannot be driven again by this socket.\r\n                this.socket.onopen = null;\r\n                this.socket.onmessage = null;\r\n                this.socket.onerror = null;\r\n                this.socket.onclose = null;\r\n                if (this.socket.readyState === 1)\r\n                    this.socket.close();\r\n                delete this.socket;\r\n            }\r\n    \r\n            if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) {\r\n                // Try the next host.\r\n                this.hostIndex++;\r\n                this._doConnect(this.connectOptions.uris[this.hostIndex]);\r\n            } else {\r\n    \r\n                if (errorCode === undefined) {\r\n                    errorCode = ERROR.OK.code;\r\n                    errorText = format(ERROR.OK);\r\n                }\r\n    \r\n                // Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\r\n                if (this.connected) {\r\n                    this.connected = false;\r\n                    // Execute the connectionLostCallback if there is one, and we were connected.\r\n                    if (this.onConnectionLost) {\r\n                        this.onConnectionLost({ errorCode: errorCode, errorMessage: errorText, reconnect: this.connectOptions.reconnect, uri: this._wsuri });\r\n                    }\r\n                    if (errorCode !== ERROR.OK.code && this.connectOptions.reconnect) {\r\n                        // Start automatic reconnect process for the very first time since last successful connect.\r\n                        this._reconnectInterval = 1;\r\n                        this._reconnect();\r\n                        return;\r\n                    }\r\n                } else {\r\n                    // Otherwise we never had a connection, so indicate that the connect has failed.\r\n                    if (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {\r\n                        this._trace(\"Failed to connect V4, dropping back to V3\");\r\n                        this.connectOptions.mqttVersion = 3;\r\n                        if (this.connectOptions.uris) {\r\n                            this.hostIndex = 0;\r\n                            this._doConnect(this.connectOptions.uris[0]);\r\n                        } else {\r\n                            this._doConnect(this.uri);\r\n                        }\r\n                    } else if (this.connectOptions.onFailure) {\r\n                        this.connectOptions.onFailure({ invocationContext: this.connectOptions.invocationContext, errorCode: errorCode, errorMessage: errorText });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype._trace = function() {\r\n            // Pass trace message back to client's callback function\r\n            if (this.traceFunction) {\r\n                for (var i in arguments) {\r\n                    if (typeof arguments[i] !== \"undefined\")\r\n                        arguments.splice(i, 1, JSON.stringify(arguments[i]));\r\n                }\r\n                var record = Array.prototype.slice.call(arguments).join(\"\");\r\n                this.traceFunction({ severity: \"Debug\", message: record });\r\n            }\r\n    \r\n            //buffer style trace\r\n            if (this._traceBuffer !== null) {\r\n                for (var i = 0, max = arguments.length; i < max; i++) {\r\n                    if (this._traceBuffer.length == this._MAX_TRACE_ENTRIES) {\r\n                        this._traceBuffer.shift();\r\n                    }\r\n                    if (i === 0) this._traceBuffer.push(arguments[i]);\r\n                    else if (typeof arguments[i] === \"undefined\") this._traceBuffer.push(arguments[i]);\r\n                    else this._traceBuffer.push(\"  \" + JSON.stringify(arguments[i]));\r\n                }\r\n            }\r\n        };\r\n    \r\n        /** @ignore */\r\n        ClientImpl.prototype._traceMask = function(traceObject, masked) {\r\n            var traceObjectMasked = {};\r\n            for (var attr in traceObject) {\r\n                if (traceObject.hasOwnProperty(attr)) {\r\n                    if (attr == masked)\r\n                        traceObjectMasked[attr] = \"******\";\r\n                    else\r\n                        traceObjectMasked[attr] = traceObject[attr];\r\n                }\r\n            }\r\n            return traceObjectMasked;\r\n        };\r\n    \r\n        // ------------------------------------------------------------------------\r\n        // Public Programming interface.\r\n        // ------------------------------------------------------------------------\r\n    \r\n        /**\r\n         * The JavaScript application communicates to the server using a {@link Paho.MQTT.Client} object.\r\n         * <p>\r\n         * Most applications will create just one Client object and then call its connect() method,\r\n         * however applications can create more than one Client object if they wish.\r\n         * In this case the combination of host, port and clientId attributes must be different for each Client object.\r\n         * <p>\r\n         * The send, subscribe and unsubscribe methods are implemented as asynchronous JavaScript methods\r\n         * (even though the underlying protocol exchange might be synchronous in nature).\r\n         * This means they signal their completion by calling back to the application,\r\n         * via Success or Failure callback functions provided by the application on the method in question.\r\n         * Such callbacks are called at most once per method invocation and do not persist beyond the lifetime\r\n         * of the script that made the invocation.\r\n         * <p>\r\n         * In contrast there are some callback functions, most notably <i>onMessageArrived</i>,\r\n         * that are defined on the {@link Paho.MQTT.Client} object.\r\n         * These may get called multiple times, and aren't directly related to specific method invocations made by the client.\r\n         *\r\n         * @name Paho.MQTT.Client\r\n         *\r\n         * @constructor\r\n         *\r\n         * @param {string} host - the address of the messaging server, as a fully qualified WebSocket URI, as a DNS name or dotted decimal IP address.\r\n         * @param {number} port - the port number to connect to - only required if host is not a URI\r\n         * @param {string} path - the path on the host to connect to - only used if host is not a URI. Default: '/mqtt'.\r\n         * @param {string} clientId - the Messaging client identifier, between 1 and 23 characters in length.\r\n         *\r\n         * @property {string} host - <i>read only</i> the server's DNS hostname or dotted decimal IP address.\r\n         * @property {number} port - <i>read only</i> the server's port.\r\n         * @property {string} path - <i>read only</i> the server's path.\r\n         * @property {string} clientId - <i>read only</i> used when connecting to the server.\r\n         * @property {function} onConnectionLost - called when a connection has been lost.\r\n         *                            after a connect() method has succeeded.\r\n         *                            Establish the call back used when a connection has been lost. The connection may be\r\n         *                            lost because the client initiates a disconnect or because the server or network\r\n         *                            cause the client to be disconnected. The disconnect call back may be called without\r\n         *                            the connectionComplete call back being invoked if, for example the client fails to\r\n         *                            connect.\r\n         *                            A single response object parameter is passed to the onConnectionLost callback containing the following fields:\r\n         *                            <ol>\r\n         *                            <li>errorCode\r\n         *                            <li>errorMessage\r\n         *                            </ol>\r\n         * @property {function} onMessageDelivered - called when a message has been delivered.\r\n         *                            All processing that this Client will ever do has been completed. So, for example,\r\n         *                            in the case of a Qos=2 message sent by this client, the PubComp flow has been received from the server\r\n         *                            and the message has been removed from persistent storage before this callback is invoked.\r\n         *                            Parameters passed to the onMessageDelivered callback are:\r\n         *                            <ol>\r\n         *                            <li>{@link Paho.MQTT.Message} that was delivered.\r\n         *                            </ol>\r\n         * @property {function} onMessageArrived - called when a message has arrived in this Paho.MQTT.client.\r\n         *                            Parameters passed to the onMessageArrived callback are:\r\n         *                            <ol>\r\n         *                            <li>{@link Paho.MQTT.Message} that has arrived.\r\n         *                            </ol>\r\n         * @property {function} onConnected - called when a connection is successfully made to the server.\r\n         *                                  after a connect() method.\r\n         *                                  Parameters passed to the onConnected callback are:\r\n         *                                  <ol>\r\n         *                                  <li>reconnect (boolean) - If true, the connection was the result of a reconnect.</li>\r\n         *                                  <li>URI (string) - The URI used to connect to the server.</li>\r\n         *                                  </ol>\r\n         * @property {boolean} disconnectedPublishing - if set, will enable disconnected publishing in\r\n         *                                            in the event that the connection to the server is lost.\r\n         * @property {number} disconnectedBufferSize - Used to set the maximum number of messages that the disconnected\r\n         *                                             buffer will hold before rejecting new messages. Default size: 5000 messages\r\n         * @property {function} trace - called whenever trace is called. TODO\r\n         */\r\n        var Client = function(host, port, path, clientId) {\r\n    \r\n            var uri;\r\n    \r\n            if (typeof host !== \"string\")\r\n                throw new Error(format(ERROR.INVALID_TYPE, [typeof host, \"host\"]));\r\n    \r\n            if (arguments.length == 2) {\r\n                // host: must be full ws:// uri\r\n                // port: clientId\r\n                clientId = port;\r\n                uri = host;\r\n                var match = uri.match(/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/);\r\n                if (match) {\r\n                    host = match[4] || match[2];\r\n                    port = parseInt(match[7]);\r\n                    path = match[8];\r\n                } else {\r\n                    throw new Error(format(ERROR.INVALID_ARGUMENT, [host, \"host\"]));\r\n                }\r\n            } else {\r\n                if (arguments.length == 3) {\r\n                    clientId = path;\r\n                    path = \"/mqtt\";\r\n                }\r\n                if (typeof port !== \"number\" || port < 0)\r\n                    throw new Error(format(ERROR.INVALID_TYPE, [typeof port, \"port\"]));\r\n                if (typeof path !== \"string\")\r\n                    throw new Error(format(ERROR.INVALID_TYPE, [typeof path, \"path\"]));\r\n    \r\n                var ipv6AddSBracket = (host.indexOf(\":\") !== -1 && host.slice(0, 1) !== \"[\" && host.slice(-1) !== \"]\");\r\n                uri = \"ws://\" + (ipv6AddSBracket ? \"[\" + host + \"]\" : host) + \":\" + port + path;\r\n            }\r\n    \r\n            var clientIdLength = 0;\r\n            for (var i = 0; i < clientId.length; i++) {\r\n                var charCode = clientId.charCodeAt(i);\r\n                if (0xD800 <= charCode && charCode <= 0xDBFF) {\r\n                    i++; // Surrogate pair.\r\n                }\r\n                clientIdLength++;\r\n            }\r\n            if (typeof clientId !== \"string\" || clientIdLength > 65535)\r\n                throw new Error(format(ERROR.INVALID_ARGUMENT, [clientId, \"clientId\"]));\r\n    \r\n            var client = new ClientImpl(uri, host, port, path, clientId);\r\n            this._getHost = function() { return host; };\r\n            this._setHost = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n    \r\n            this._getPort = function() { return port; };\r\n            this._setPort = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n    \r\n            this._getPath = function() { return path; };\r\n            this._setPath = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n    \r\n            this._getURI = function() { return uri; };\r\n            this._setURI = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n    \r\n            this._getClientId = function() { return client.clientId; };\r\n            this._setClientId = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\r\n    \r\n            this._getOnConnected = function() { return client.onConnected; };\r\n            this._setOnConnected = function(newOnConnected) {\r\n                if (typeof newOnConnected === \"function\")\r\n                    client.onConnected = newOnConnected;\r\n                else\r\n                    throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnected, \"onConnected\"]));\r\n            };\r\n    \r\n            this._getDisconnectedPublishing = function() { return client.disconnectedPublishing; };\r\n            this._setDisconnectedPublishing = function(newDisconnectedPublishing) {\r\n                client.disconnectedPublishing = newDisconnectedPublishing;\r\n            };\r\n    \r\n            this._getDisconnectedBufferSize = function() { return client.disconnectedBufferSize; };\r\n            this._setDisconnectedBufferSize = function(newDisconnectedBufferSize) {\r\n                client.disconnectedBufferSize = newDisconnectedBufferSize;\r\n            };\r\n    \r\n            this._getOnConnectionLost = function() { return client.onConnectionLost; };\r\n            this._setOnConnectionLost = function(newOnConnectionLost) {\r\n                if (typeof newOnConnectionLost === \"function\")\r\n                    client.onConnectionLost = newOnConnectionLost;\r\n                else\r\n                    throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, \"onConnectionLost\"]));\r\n            };\r\n    \r\n            this._getOnMessageDelivered = function() { return client.onMessageDelivered; };\r\n            this._setOnMessageDelivered = function(newOnMessageDelivered) {\r\n                if (typeof newOnMessageDelivered === \"function\")\r\n                    client.onMessageDelivered = newOnMessageDelivered;\r\n                else\r\n                    throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, \"onMessageDelivered\"]));\r\n            };\r\n    \r\n            this._getOnMessageArrived = function() { return client.onMessageArrived; };\r\n            this._setOnMessageArrived = function(newOnMessageArrived) {\r\n                if (typeof newOnMessageArrived === \"function\")\r\n                    client.onMessageArrived = newOnMessageArrived;\r\n                else\r\n                    throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, \"onMessageArrived\"]));\r\n            };\r\n    \r\n            this._getTrace = function() { return client.traceFunction; };\r\n            this._setTrace = function(trace) {\r\n                if (typeof trace === \"function\") {\r\n                    client.traceFunction = trace;\r\n                } else {\r\n                    throw new Error(format(ERROR.INVALID_TYPE, [typeof trace, \"onTrace\"]));\r\n                }\r\n            };\r\n    \r\n            /**\r\n             * Connect this Messaging client to its server.\r\n             *\r\n             * @name Paho.MQTT.Client#connect\r\n             * @function\r\n             * @param {object} connectOptions - Attributes used with the connection.\r\n             * @param {number} connectOptions.timeout - If the connect has not succeeded within this\r\n             *                    number of seconds, it is deemed to have failed.\r\n             *                    The default is 30 seconds.\r\n             * @param {string} connectOptions.userName - Authentication username for this connection.\r\n             * @param {string} connectOptions.password - Authentication password for this connection.\r\n             * @param {Paho.MQTT.Message} connectOptions.willMessage - sent by the server when the client\r\n             *                    disconnects abnormally.\r\n             * @param {number} connectOptions.keepAliveInterval - the server disconnects this client if\r\n             *                    there is no activity for this number of seconds.\r\n             *                    The default value of 60 seconds is assumed if not set.\r\n             * @param {boolean} connectOptions.cleanSession - if true(default) the client and server\r\n             *                    persistent state is deleted on successful connect.\r\n             * @param {boolean} connectOptions.useSSL - if present and true, use an SSL Websocket connection.\r\n             * @param {object} connectOptions.invocationContext - passed to the onSuccess callback or onFailure callback.\r\n             * @param {function} connectOptions.onSuccess - called when the connect acknowledgement\r\n             *                    has been received from the server.\r\n             * A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n             * <ol>\r\n             * <li>invocationContext as passed in to the onSuccess method in the connectOptions.\r\n             * </ol>\r\n             * @param {function} connectOptions.onFailure - called when the connect request has failed or timed out.\r\n             * A single response object parameter is passed to the onFailure callback containing the following fields:\r\n             * <ol>\r\n             * <li>invocationContext as passed in to the onFailure method in the connectOptions.\r\n             * <li>errorCode a number indicating the nature of the error.\r\n             * <li>errorMessage text describing the error.\r\n             * </ol>\r\n             * @param {array} connectOptions.hosts - If present this contains either a set of hostnames or fully qualified\r\n             * WebSocket URIs (ws://iot.eclipse.org:80/ws), that are tried in order in place\r\n             * of the host and port paramater on the construtor. The hosts are tried one at at time in order until\r\n             * one of then succeeds.\r\n             * @param {array} connectOptions.ports - If present the set of ports matching the hosts. If hosts contains URIs, this property\r\n             * is not used.\r\n             * @param {boolean} connectOptions.reconnect - Sets whether the client will automatically attempt to reconnect\r\n             * to the server if the connection is lost.\r\n             *<ul>\r\n             *<li>If set to false, the client will not attempt to automatically reconnect to the server in the event that the\r\n             * connection is lost.</li>\r\n             *<li>If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server.\r\n             * It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay\r\n             * will double until it is at 2 minutes at which point the delay will stay at 2 minutes.</li>\r\n             *</ul>\r\n             * @param {number} connectOptions.mqttVersion - The version of MQTT to use to connect to the MQTT Broker.\r\n             *<ul>\r\n             *<li>3 - MQTT V3.1</li>\r\n             *<li>4 - MQTT V3.1.1</li>\r\n             *</ul>\r\n             * @param {boolean} connectOptions.mqttVersionExplicit - If set to true, will force the connection to use the\r\n             * selected MQTT Version or will fail to connect.\r\n             * @param {array} connectOptions.uris - If present, should contain a list of fully qualified WebSocket uris\r\n             * (e.g. ws://iot.eclipse.org:80/ws), that are tried in order in place of the host and port parameter of the construtor.\r\n             * The uris are tried one at a time in order until one of them succeeds. Do not use this in conjunction with hosts as\r\n             * the hosts array will be converted to uris and will overwrite this property.\r\n             * @throws {InvalidState} If the client is not in disconnected state. The client must have received connectionLost\r\n             * or disconnected before calling connect for a second or subsequent time.\r\n             */\r\n            this.connect = function(connectOptions) {\r\n                connectOptions = connectOptions || {};\r\n                validate(connectOptions, {\r\n                    timeout: \"number\",\r\n                    userName: \"string\",\r\n                    password: \"string\",\r\n                    willMessage: \"object\",\r\n                    keepAliveInterval: \"number\",\r\n                    cleanSession: \"boolean\",\r\n                    useSSL: \"boolean\",\r\n                    invocationContext: \"object\",\r\n                    onSuccess: \"function\",\r\n                    onFailure: \"function\",\r\n                    hosts: \"object\",\r\n                    ports: \"object\",\r\n                    reconnect: \"boolean\",\r\n                    mqttVersion: \"number\",\r\n                    mqttVersionExplicit: \"boolean\",\r\n                    uris: \"object\"\r\n                });\r\n    \r\n                // If no keep alive interval is set, assume 60 seconds.\r\n                if (connectOptions.keepAliveInterval === undefined)\r\n                    connectOptions.keepAliveInterval = 60;\r\n    \r\n                if (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {\r\n                    throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, \"connectOptions.mqttVersion\"]));\r\n                }\r\n    \r\n                if (connectOptions.mqttVersion === undefined) {\r\n                    connectOptions.mqttVersionExplicit = false;\r\n                    connectOptions.mqttVersion = 4;\r\n                } else {\r\n                    connectOptions.mqttVersionExplicit = true;\r\n                }\r\n    \r\n                //Check that if password is set, so is username\r\n                if (connectOptions.password !== undefined && connectOptions.userName === undefined)\r\n                    throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, \"connectOptions.password\"]));\r\n    \r\n                if (connectOptions.willMessage) {\r\n                    if (!(connectOptions.willMessage instanceof Message))\r\n                        throw new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, \"connectOptions.willMessage\"]));\r\n                    // The will message must have a payload that can be represented as a string.\r\n                    // Cause the willMessage to throw an exception if this is not the case.\r\n                    connectOptions.willMessage.stringPayload = null;\r\n    \r\n                    if (typeof connectOptions.willMessage.destinationName === \"undefined\")\r\n                        throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, \"connectOptions.willMessage.destinationName\"]));\r\n                }\r\n                if (typeof connectOptions.cleanSession === \"undefined\")\r\n                    connectOptions.cleanSession = true;\r\n                if (connectOptions.hosts) {\r\n    \r\n                    if (!(connectOptions.hosts instanceof Array))\r\n                        throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\r\n                    if (connectOptions.hosts.length < 1)\r\n                        throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\r\n    \r\n                    var usingURIs = false;\r\n                    for (var i = 0; i < connectOptions.hosts.length; i++) {\r\n                        if (typeof connectOptions.hosts[i] !== \"string\")\r\n                            throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\r\n                        if (/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(connectOptions.hosts[i])) {\r\n                            if (i === 0) {\r\n                                usingURIs = true;\r\n                            } else if (!usingURIs) {\r\n                                throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\r\n                            }\r\n                        } else if (usingURIs) {\r\n                            throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], \"connectOptions.hosts[\" + i + \"]\"]));\r\n                        }\r\n                    }\r\n    \r\n                    if (!usingURIs) {\r\n                        if (!connectOptions.ports)\r\n                            throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\r\n                        if (!(connectOptions.ports instanceof Array))\r\n                            throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\r\n                        if (connectOptions.hosts.length !== connectOptions.ports.length)\r\n                            throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\r\n    \r\n                        connectOptions.uris = [];\r\n    \r\n                        for (var i = 0; i < connectOptions.hosts.length; i++) {\r\n                            if (typeof connectOptions.ports[i] !== \"number\" || connectOptions.ports[i] < 0)\r\n                                throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], \"connectOptions.ports[\" + i + \"]\"]));\r\n                            var host = connectOptions.hosts[i];\r\n                            var port = connectOptions.ports[i];\r\n    \r\n                            var ipv6 = (host.indexOf(\":\") !== -1);\r\n                            uri = \"ws://\" + (ipv6 ? \"[\" + host + \"]\" : host) + \":\" + port + path;\r\n                            connectOptions.uris.push(uri);\r\n                        }\r\n                    } else {\r\n                        connectOptions.uris = connectOptions.hosts;\r\n                    }\r\n                }\r\n    \r\n                client.connect(connectOptions);\r\n            };\r\n    \r\n            /**\r\n             * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\r\n             *\r\n             * @name Paho.MQTT.Client#subscribe\r\n             * @function\r\n             * @param {string} filter describing the destinations to receive messages from.\r\n             * <br>\r\n             * @param {object} subscribeOptions - used to control the subscription\r\n             *\r\n             * @param {number} subscribeOptions.qos - the maiximum qos of any publications sent\r\n             *                                  as a result of making this subscription.\r\n             * @param {object} subscribeOptions.invocationContext - passed to the onSuccess callback\r\n             *                                  or onFailure callback.\r\n             * @param {function} subscribeOptions.onSuccess - called when the subscribe acknowledgement\r\n             *                                  has been received from the server.\r\n             *                                  A single response object parameter is passed to the onSuccess callback containing the following fields:\r\n             *                                  <ol>\r\n             *                                  <li>invocationContext if set in the subscribeOptions.\r\n             *                                  </ol>\r\n             * @param {function} subscribeOptions.onFailure - called when the subscribe request has failed or timed out.\r\n             *                                  A single response object parameter is passed to the onFailure callback containing the following fields:\r\n             *                                  <ol>\r\n             *                                  <li>invocationContext - if set in the subscribeOptions.\r\n             *                                  <li>errorCode - a number indicating the nature of the error.\r\n             *                                  <li>errorMessage - text describing the error.\r\n             *                                  </ol>\r\n             * @param {number} subscribeOptions.timeout - which, if present, determines the number of\r\n             *                                  seconds after which the onFailure calback is called.\r\n             *                                  The presence of a timeout does not prevent the onSuccess\r\n             *                                  callback from being called when the subscribe completes.\r\n             * @throws {InvalidState} if the client is not in connected state.\r\n             */\r\n            this.subscribe = function(filter, subscribeOptions) {\r\n                if (typeof filter !== \"string\")\r\n                    throw new Error(\"Invalid argument:\" + filter);\r\n                subscribeOptions = subscribeOptions || {};\r\n                validate(subscribeOptions, {\r\n                    qos: \"number\",\r\n                    invocationContext: \"object\",\r\n                    onSuccess: \"function\",\r\n                    onFailure: \"function\",\r\n                    timeout: \"number\"\r\n                });\r\n                if (subscribeOptions.timeout && !subscribeOptions.onFailure)\r\n                    throw new Error(\"subscribeOptions.timeout specified with no onFailure callback.\");\r\n                if (typeof subscribeOptions.qos !== \"undefined\" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2))\r\n                    throw new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, \"subscribeOptions.qos\"]));\r\n                client.subscribe(filter, subscribeOptions);\r\n            };\r\n    \r\n            /**\r\n             * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\r\n             *\r\n             * @name Paho.MQTT.Client#unsubscribe\r\n             * @function\r\n             * @param {string} filter - describing the destinations to receive messages from.\r\n             * @param {object} unsubscribeOptions - used to control the subscription\r\n             * @param {object} unsubscribeOptions.invocationContext - passed to the onSuccess callback\r\n                                                  or onFailure callback.\r\n             * @param {function} unsubscribeOptions.onSuccess - called when the unsubscribe acknowledgement has been received from the server.\r\n             *                                    A single response object parameter is passed to the\r\n             *                                    onSuccess callback containing the following fields:\r\n             *                                    <ol>\r\n             *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n             *                                    </ol>\r\n             * @param {function} unsubscribeOptions.onFailure called when the unsubscribe request has failed or timed out.\r\n             *                                    A single response object parameter is passed to the onFailure callback containing the following fields:\r\n             *                                    <ol>\r\n             *                                    <li>invocationContext - if set in the unsubscribeOptions.\r\n             *                                    <li>errorCode - a number indicating the nature of the error.\r\n             *                                    <li>errorMessage - text describing the error.\r\n             *                                    </ol>\r\n             * @param {number} unsubscribeOptions.timeout - which, if present, determines the number of seconds\r\n             *                                    after which the onFailure callback is called. The presence of\r\n             *                                    a timeout does not prevent the onSuccess callback from being\r\n             *                                    called when the unsubscribe completes\r\n             * @throws {InvalidState} if the client is not in connected state.\r\n             */\r\n            this.unsubscribe = function(filter, unsubscribeOptions) {\r\n                if (typeof filter !== \"string\")\r\n                    throw new Error(\"Invalid argument:\" + filter);\r\n                unsubscribeOptions = unsubscribeOptions || {};\r\n                validate(unsubscribeOptions, {\r\n                    invocationContext: \"object\",\r\n                    onSuccess: \"function\",\r\n                    onFailure: \"function\",\r\n                    timeout: \"number\"\r\n                });\r\n                if (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure)\r\n                    throw new Error(\"unsubscribeOptions.timeout specified with no onFailure callback.\");\r\n                client.unsubscribe(filter, unsubscribeOptions);\r\n            };\r\n    \r\n            /**\r\n             * Send a message to the consumers of the destination in the Message.\r\n             *\r\n             * @name Paho.MQTT.Client#send\r\n             * @function\r\n             * @param {string|Paho.MQTT.Message} topic - <b>mandatory</b> The name of the destination to which the message is to be sent.\r\n             *                     - If it is the only parameter, used as Paho.MQTT.Message object.\r\n             * @param {String|ArrayBuffer} payload - The message data to be sent.\r\n             * @param {number} qos The Quality of Service used to deliver the message.\r\n             *      <dl>\r\n             *          <dt>0 Best effort (default).\r\n             *              <dt>1 At least once.\r\n             *              <dt>2 Exactly once.\r\n             *      </dl>\r\n             * @param {Boolean} retained If true, the message is to be retained by the server and delivered\r\n             *                     to both current and future subscriptions.\r\n             *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n             *                     A received message has the retained boolean set to true if the message was published\r\n             *                     with the retained boolean set to true\r\n             *                     and the subscrption was made after the message has been published.\r\n             * @throws {InvalidState} if the client is not connected.\r\n             */\r\n            this.send = function(topic, payload, qos, retained) {\r\n                var message;\r\n    \r\n                if (arguments.length === 0) {\r\n                    throw new Error(\"Invalid argument.\" + \"length\");\r\n    \r\n                } else if (arguments.length == 1) {\r\n    \r\n                    if (!(topic instanceof Message) && (typeof topic !== \"string\"))\r\n                        throw new Error(\"Invalid argument:\" + typeof topic);\r\n    \r\n                    message = topic;\r\n                    if (typeof message.destinationName === \"undefined\")\r\n                        throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, \"Message.destinationName\"]));\r\n                    client.send(message);\r\n    \r\n                } else {\r\n                    //parameter checking in Message object\r\n                    message = new Message(payload);\r\n                    message.destinationName = topic;\r\n                    if (arguments.length >= 3)\r\n                        message.qos = qos;\r\n                    if (arguments.length >= 4)\r\n                        message.retained = retained;\r\n                    client.send(message);\r\n                }\r\n            };\r\n    \r\n            /**\r\n             * Publish a message to the consumers of the destination in the Message.\r\n             * Synonym for Paho.Mqtt.Client#send\r\n             *\r\n             * @name Paho.MQTT.Client#publish\r\n             * @function\r\n             * @param {string|Paho.MQTT.Message} topic - <b>mandatory</b> The name of the topic to which the message is to be published.\r\n             *                     - If it is the only parameter, used as Paho.MQTT.Message object.\r\n             * @param {String|ArrayBuffer} payload - The message data to be published.\r\n             * @param {number} qos The Quality of Service used to deliver the message.\r\n             *      <dl>\r\n             *          <dt>0 Best effort (default).\r\n             *              <dt>1 At least once.\r\n             *              <dt>2 Exactly once.\r\n             *      </dl>\r\n             * @param {Boolean} retained If true, the message is to be retained by the server and delivered\r\n             *                     to both current and future subscriptions.\r\n             *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n             *                     A received message has the retained boolean set to true if the message was published\r\n             *                     with the retained boolean set to true\r\n             *                     and the subscrption was made after the message has been published.\r\n             * @throws {InvalidState} if the client is not connected.\r\n             */\r\n            this.publish = function(topic, payload, qos, retained) {\r\n                console.log(\"Publising message to: \", topic);\r\n                var message;\r\n    \r\n                if (arguments.length === 0) {\r\n                    throw new Error(\"Invalid argument.\" + \"length\");\r\n    \r\n                } else if (arguments.length == 1) {\r\n    \r\n                    if (!(topic instanceof Message) && (typeof topic !== \"string\"))\r\n                        throw new Error(\"Invalid argument:\" + typeof topic);\r\n    \r\n                    message = topic;\r\n                    if (typeof message.destinationName === \"undefined\")\r\n                        throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, \"Message.destinationName\"]));\r\n                    client.send(message);\r\n    \r\n                } else {\r\n                    //parameter checking in Message object\r\n                    message = new Message(payload);\r\n                    message.destinationName = topic;\r\n                    if (arguments.length >= 3)\r\n                        message.qos = qos;\r\n                    if (arguments.length >= 4)\r\n                        message.retained = retained;\r\n                    client.send(message);\r\n                }\r\n            };\r\n    \r\n            /**\r\n             * Normal disconnect of this Messaging client from its server.\r\n             *\r\n             * @name Paho.MQTT.Client#disconnect\r\n             * @function\r\n             * @throws {InvalidState} if the client is already disconnected.\r\n             */\r\n            this.disconnect = function() {\r\n                client.disconnect();\r\n            };\r\n    \r\n            /**\r\n             * Get the contents of the trace log.\r\n             *\r\n             * @name Paho.MQTT.Client#getTraceLog\r\n             * @function\r\n             * @return {Object[]} tracebuffer containing the time ordered trace records.\r\n             */\r\n            this.getTraceLog = function() {\r\n                return client.getTraceLog();\r\n            };\r\n    \r\n            /**\r\n             * Start tracing.\r\n             *\r\n             * @name Paho.MQTT.Client#startTrace\r\n             * @function\r\n             */\r\n            this.startTrace = function() {\r\n                client.startTrace();\r\n            };\r\n    \r\n            /**\r\n             * Stop tracing.\r\n             *\r\n             * @name Paho.MQTT.Client#stopTrace\r\n             * @function\r\n             */\r\n            this.stopTrace = function() {\r\n                client.stopTrace();\r\n            };\r\n    \r\n            this.isConnected = function() {\r\n                return client.connected;\r\n            };\r\n        };\r\n    \r\n        Client.prototype = {\r\n            get host() { return this._getHost(); },\r\n            set host(newHost) { this._setHost(newHost); },\r\n    \r\n            get port() { return this._getPort(); },\r\n            set port(newPort) { this._setPort(newPort); },\r\n    \r\n            get path() { return this._getPath(); },\r\n            set path(newPath) { this._setPath(newPath); },\r\n    \r\n            get clientId() { return this._getClientId(); },\r\n            set clientId(newClientId) { this._setClientId(newClientId); },\r\n    \r\n            get onConnected() { return this._getOnConnected(); },\r\n            set onConnected(newOnConnected) { this._setOnConnected(newOnConnected); },\r\n    \r\n            get disconnectedPublishing() { return this._getDisconnectedPublishing(); },\r\n            set disconnectedPublishing(newDisconnectedPublishing) { this._setDisconnectedPublishing(newDisconnectedPublishing); },\r\n    \r\n            get disconnectedBufferSize() { return this._getDisconnectedBufferSize(); },\r\n            set disconnectedBufferSize(newDisconnectedBufferSize) { this._setDisconnectedBufferSize(newDisconnectedBufferSize); },\r\n    \r\n            get onConnectionLost() { return this._getOnConnectionLost(); },\r\n            set onConnectionLost(newOnConnectionLost) { this._setOnConnectionLost(newOnConnectionLost); },\r\n    \r\n            get onMessageDelivered() { return this._getOnMessageDelivered(); },\r\n            set onMessageDelivered(newOnMessageDelivered) { this._setOnMessageDelivered(newOnMessageDelivered); },\r\n    \r\n            get onMessageArrived() { return this._getOnMessageArrived(); },\r\n            set onMessageArrived(newOnMessageArrived) { this._setOnMessageArrived(newOnMessageArrived); },\r\n    \r\n            get trace() { return this._getTrace(); },\r\n            set trace(newTraceFunction) { this._setTrace(newTraceFunction); }\r\n    \r\n        };\r\n    \r\n        /**\r\n         * An application message, sent or received.\r\n         * <p>\r\n         * All attributes may be null, which implies the default values.\r\n         *\r\n         * @name Paho.MQTT.Message\r\n         * @constructor\r\n         * @param {String|ArrayBuffer} payload The message data to be sent.\r\n         * <p>\r\n         * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\r\n         * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\r\n         * <p>\r\n         * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\r\n         *                    (for messages about to be sent) or the name of the destination from which the message has been received.\r\n         *                    (for messages received by the onMessage function).\r\n         * <p>\r\n         * @property {number} qos The Quality of Service used to deliver the message.\r\n         * <dl>\r\n         *     <dt>0 Best effort (default).\r\n         *     <dt>1 At least once.\r\n         *     <dt>2 Exactly once.\r\n         * </dl>\r\n         * <p>\r\n         * @property {Boolean} retained If true, the message is to be retained by the server and delivered\r\n         *                     to both current and future subscriptions.\r\n         *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\r\n         *                     A received message has the retained boolean set to true if the message was published\r\n         *                     with the retained boolean set to true\r\n         *                     and the subscrption was made after the message has been published.\r\n         * <p>\r\n         * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received.\r\n         *                     This is only set on messages received from the server.\r\n         *\r\n         */\r\n        var Message = function(newPayload) {\r\n            var payload;\r\n            if (typeof newPayload === \"string\" ||\r\n                newPayload instanceof ArrayBuffer ||\r\n                newPayload instanceof Int8Array ||\r\n                newPayload instanceof Uint8Array ||\r\n                newPayload instanceof Int16Array ||\r\n                newPayload instanceof Uint16Array ||\r\n                newPayload instanceof Int32Array ||\r\n                newPayload instanceof Uint32Array ||\r\n                newPayload instanceof Float32Array ||\r\n                newPayload instanceof Float64Array\r\n            ) {\r\n                payload = newPayload;\r\n            } else {\r\n                throw (format(ERROR.INVALID_ARGUMENT, [newPayload, \"newPayload\"]));\r\n            }\r\n    \r\n            this._getPayloadString = function() {\r\n                if (typeof payload === \"string\")\r\n                    return payload;\r\n                else\r\n                    return parseUTF8(payload, 0, payload.length);\r\n            };\r\n    \r\n            this._getPayloadBytes = function() {\r\n                if (typeof payload === \"string\") {\r\n                    var buffer = new ArrayBuffer(UTF8Length(payload));\r\n                    var byteStream = new Uint8Array(buffer);\r\n                    stringToUTF8(payload, byteStream, 0);\r\n    \r\n                    return byteStream;\r\n                } else {\r\n                    return payload;\r\n                }\r\n            };\r\n    \r\n            var destinationName;\r\n            this._getDestinationName = function() { return destinationName; };\r\n            this._setDestinationName = function(newDestinationName) {\r\n                if (typeof newDestinationName === \"string\")\r\n                    destinationName = newDestinationName;\r\n                else\r\n                    throw new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, \"newDestinationName\"]));\r\n            };\r\n    \r\n            var qos = 0;\r\n            this._getQos = function() { return qos; };\r\n            this._setQos = function(newQos) {\r\n                if (newQos === 0 || newQos === 1 || newQos === 2)\r\n                    qos = newQos;\r\n                else\r\n                    throw new Error(\"Invalid argument:\" + newQos);\r\n            };\r\n    \r\n            var retained = false;\r\n            this._getRetained = function() { return retained; };\r\n            this._setRetained = function(newRetained) {\r\n                if (typeof newRetained === \"boolean\")\r\n                    retained = newRetained;\r\n                else\r\n                    throw new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, \"newRetained\"]));\r\n            };\r\n    \r\n            var duplicate = false;\r\n            this._getDuplicate = function() { return duplicate; };\r\n            this._setDuplicate = function(newDuplicate) { duplicate = newDuplicate; };\r\n        };\r\n    \r\n        Message.prototype = {\r\n            get payloadString() { return this._getPayloadString(); },\r\n            get payloadBytes() { return this._getPayloadBytes(); },\r\n    \r\n            get destinationName() { return this._getDestinationName(); },\r\n            set destinationName(newDestinationName) { this._setDestinationName(newDestinationName); },\r\n    \r\n            get topic() { return this._getDestinationName(); },\r\n            set topic(newTopic) { this._setDestinationName(newTopic); },\r\n    \r\n            get qos() { return this._getQos(); },\r\n            set qos(newQos) { this._setQos(newQos); },\r\n    \r\n            get retained() { return this._getRetained(); },\r\n            set retained(newRetained) { this._setRetained(newRetained); },\r\n    \r\n            get duplicate() { return this._getDuplicate(); },\r\n            set duplicate(newDuplicate) { this._setDuplicate(newDuplicate); }\r\n        };\r\n    \r\n        // Module contents.\r\n        return {\r\n            Client: Client,\r\n            Message: Message\r\n        };\r\n    })(window);\r\n    \r\n    export default Paho;\r\n    // return PahoMQTT;\r\n    // });"]}]}